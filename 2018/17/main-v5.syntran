
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let MOVING   = "|";
let STANDING = "~";

fn part1(): str
{
	let sum_ = 0'i64;

	// First pass: get bounds
	let xmin =  2_000_000_000;
	let ymin =  2_000_000_000;
	let xmax = -2_000_000_000;
	let ymax = -2_000_000_000;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];

			xmin = min(xmin, x);
			xmax = max(xmax, x);

			ymin = min(ymin, y0);
			ymax = max(ymax, y0);
			ymin = min(ymin, y1);
			ymax = max(ymax, y1);
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];

			ymin = min(ymin, y);
			ymax = max(ymax, y);

			xmin = min(xmin, x0);
			xmax = max(xmax, x0);
			xmin = min(xmin, x1);
			xmax = max(xmax, x1);
		}

		str_ = readln(f);
	}
	close(f);

	// Water spring/source
	let xs = 500;
	let ys = 0;

	// Include spring in bounds
	ymin = min(ymin, ys);

	// Pad x (but not y) by 1.  Water may flow one past outer bound before
	// padding
	xmin -= 1;
	xmax += 1;

	// Pad upper bounds because input is inclusive
	xmax += 1;
	ymax += 1;

	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);

	let dx = xmax - xmin;
	let dy = ymax - ymin;

	let g = ["."; dx, dy];

	// Second pass: save

	f = open(filename, "r");
	str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];
			g[x - xmin, [y0: y1+1] - ymin] = "#";
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];
			g[[x0: x1+1] - xmin, y - ymin] = "#";
		}
		str_ = readln(f);
	}
	close(f);
	print_char_mat(&g);

	let x = xs - xmin;  let y = ys + 1 - ymin;

	//for i in [0: 10]
	//while true
	//{
		//let g0 = g;
		//let visited = [false; dx, dy];

		dfs(x, y, &g, MOVING);

		sum_ = count(g == "|") + count(g == "~");
		println("sum_ = ", sum_);
		//println("xf, yf = ", [xf, yf]);

		sum_ = count(g == "|") + count(g == "~");
		println("sum_ = ", sum_);
		println();
		//if all(g == g0)
		//{
		//	// TODO: wierd whitespace issue where this crashes if i remove
		//	// brackets and one-line both if-statements here
		//	break;
		//}
	//}
	print_char_mat(&g);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn dfs(x: i32, y: i32, g: &[str; :, :], char_: str)
{
	//if (g[x,y] != ".") return;
	if (g[x,y] == "#") return;
	if (g[x,y] == "~") return;
	//if (not any(g[x,y] == [".", "|"])) return;

	let nx = i32(size(g,0));
	let ny = i32(size(g,1));
	//if (y >= ny) 
	if not in_bounds([0,0], [x,y], [nx,ny])
	{
		return;
	}

	//println("x, y = ", [x, y]);

	// Move down when possible
	let down = true;
	if y < ny-1
	{
		down = any(g[x, y+1] == [".", "|"]);
		//down = g[x, y+1] == ".";
	}
	else
	{
		g[x, y] = MOVING;
		return;
	}

	if down
	{
		g[x, y] = char_;
		//println("recurse");
		dfs(x, y+1, &g, char_);
	}
	else
	{
		//if g[x, y] == "~"
		//	return;

		g[x, y] = MOVING;

		//print_char_mat(&g);

		// Go left
		let xl = x - 1;
		while true
		{
			if (g[xl, y+1] == "." or g[xl, y+1] == "|") break;  // found an outlet
			if (g[xl, y  ] == "#") break;  // blocked
			g[xl, y] = MOVING;
			xl -= 1;
		}
		if (g[xl, y] != "#")
		{
			//if g[xl, y] == MOVING
			if g[xl, y+1] == MOVING
			{
				//return;
			}
			else
			{
				g[xl, y] = MOVING;
				dfs(xl, y+1, &g, MOVING);
			}
		}

		// Go right
		let xr = x + 1;
		while true
		{
			if (g[xr, y+1] == "." or g[xr, y+1] == "|") break;
			if (g[xr, y  ] == "#") break;
			g[xr, y] = MOVING;
			xr += 1;
		}
		if (g[xr, y] != "#")
		{
			//if g[xr, y] == MOVING
			if g[xr, y+1] == MOVING
			{
				//return;
			}
			else
			{
				g[xr, y] = MOVING;
				dfs(xr, y+1, &g, MOVING);
			}
		}

		if all(g[[xl,xr], y] == "#")
		{
			g[xl+1: xr, y] = STANDING;

			// Backtrack to point above

			//println("backtracking");
			//if g[x, y-1] == "|" or g[x, y-1] == "."
				dfs(x, y-1, &g, MOVING);
		}
	}
	return;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/17");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

