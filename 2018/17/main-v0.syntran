
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let MOVING   = "|";
let STANDING = "~";

fn part1(): str
{
	let sum_ = 0'i64;

	// First pass: get bounds
	let xmin =  2_000_000_000;
	let ymin =  2_000_000_000;
	let xmax = -2_000_000_000;
	let ymax = -2_000_000_000;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];

			xmin = min(xmin, x);
			xmax = max(xmax, x);

			ymin = min(ymin, y0);
			ymax = max(ymax, y0);
			ymin = min(ymin, y1);
			ymax = max(ymax, y1);
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];

			ymin = min(ymin, y);
			ymax = max(ymax, y);

			xmin = min(xmin, x0);
			xmax = max(xmax, x0);
			xmin = min(xmin, x1);
			xmax = max(xmax, x1);
		}

		str_ = readln(f);
	}
	close(f);

	// Water spring/source
	let xs = 500;
	let ys = 0;

	// Include spring in bounds
	ymin = min(ymin, ys);

	// Pad x (but not y) by 1.  Water may flow one past outer bound before
	// padding
	xmin -= 1;
	xmax += 1;

	// Pad upper bounds because input is inclusive
	xmax += 1;
	ymax += 1;

	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);

	let dx = xmax - xmin;
	let dy = ymax - ymin;

	let g = ["."; dx, dy];

	// Second pass: save

	f = open(filename, "r");
	str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];
			g[x - xmin, [y0: y1+1] - ymin] = "#";
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];
			g[[x0: x1+1] - xmin, y - ymin] = "#";
		}
		str_ = readln(f);
	}
	close(f);
	print_char_mat(&g);

	for i in [0: 5]
		dfs(xs - xmin, ys + 1 - ymin, &g, MOVING);

	print_char_mat(&g);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn dfs(x: i32, y: i32, g: &[str; :, :], char_: str)
{
	//if (g[x,y] != ".") return;
	if (g[x,y] == "#") return;
	if (g[x,y] == "~") return;

	let ny = size(g,1);
	if (y >= ny) return;

	//g[x, y] = char_;

	// Move down when possible
	let down = true;
	if y < ny-1
	{
		//down = g[x, y+1] == ".";
		//down = g[x, y+1] != "#";
		down = any(g[x, y+1] == [".", "|"]);
	}

	if down
	{
		g[x, y] = char_;
		dfs(x, y+1, &g, char_);
	}
	else
	{
		g[x, y] = STANDING;
		dfs(x-1, y, &g, STANDING);
		dfs(x+1, y, &g, STANDING);
	}

	return;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/17");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

