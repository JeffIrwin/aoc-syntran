
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let MOVING   = "|";
let STANDING = "~";

fn part1(): str
{
	let sum_ = 0'i64;

	// First pass: get bounds
	let xmin =  2_000_000_000;
	let ymin =  2_000_000_000;
	let xmax = -2_000_000_000;
	let ymax = -2_000_000_000;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];

			xmin = min(xmin, x);
			xmax = max(xmax, x);

			ymin = min(ymin, y0);
			ymax = max(ymax, y0);
			ymin = min(ymin, y1);
			ymax = max(ymax, y1);
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];

			ymin = min(ymin, y);
			ymax = max(ymax, y);

			xmin = min(xmin, x0);
			xmax = max(xmax, x0);
			xmin = min(xmin, x1);
			xmax = max(xmax, x1);
		}

		str_ = readln(f);
	}
	close(f);

	// Water spring/source
	let xs = 500;
	let ys = 0;

	// Include spring in bounds
	ymin = min(ymin, ys);

	// Pad x (but not y) by 1.  Water may flow one past outer bound before
	// padding
	xmin -= 1;
	xmax += 1;

	// Pad upper bounds because input is inclusive
	xmax += 1;
	ymax += 1;

	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);

	let dx = xmax - xmin;
	let dy = ymax - ymin;

	let g = ["."; dx, dy];

	// Second pass: save

	f = open(filename, "r");
	str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];
			g[x - xmin, [y0: y1+1] - ymin] = "#";
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];
			g[[x0: x1+1] - xmin, y - ymin] = "#";
		}
		str_ = readln(f);
	}
	close(f);
	print_char_mat(&g);

	let x = xs - xmin;  let y = ys + 1 - ymin;

	//for i in [0: 10]
	//while true
	{
		let g0 = g;
		let xf = x;  let yf = y;
		let visited = [false; dx, dy];

		dfs(x, y, &g, MOVING, &xf, &yf, &visited);

		sum_ = count(g == "|") + count(g == "~");
		println("sum_ = ", sum_);
		println("xf, yf = ", [xf, yf]);

		//if (yf < dy-1)
		//{
		//	let xl = xf;
		//	while (g[xl, yf] != "#")
		//		xl -= 1;
		//	xl += 1;
		//	let xr = xf;
		//	while (g[xr, yf] != "#")
		//		xr += 1;
		//	xr -= 1;
		//	println("xl, xr = ", [xl, xr]);
		//	g[xl: xr+1, yf] = "~";
		//}

		sum_ = count(g == "|") + count(g == "~");
		println("sum_ = ", sum_);
		println();
		if all(g == g0)
		{
			// TODO: wierd whitespace issue where this crashes if i remove
			// brackets and one-line both if-statements here
			break;
		}
	}
	print_char_mat(&g);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn dfs
(
	x: i32, y: i32,
	g: &[str; :, :],
	char_: str,
	xf: &i32, yf: &i32,
	visited: &[bool; :, :]
)
{
	//if (g[x,y] != ".") return;
	if (g[x,y] == "#") return;
	if (g[x,y] == "~") return;
	//if (not any(g[x,y] == [".", "|"])) return;

	let ny = size(g,1);
	if (y >= ny) return;

	//if (visited[x,y]) return;
	//visited[x,y] = true;
	println("x, y = ", [x, y]);

	xf = x; yf = y;

	// Move down when possible
	let down = true;
	if y < ny-1
		down = any(g[x, y+1] == [".", "|"]);
	else
	{
		g[x, y] = MOVING;
		return;
	}

	if down
	{
		g[x, y] = char_;
		dfs(x, y+1, &g, char_, &xf, &yf, &visited);
	}
	else
	{
		g[x, y] = MOVING;

		//dfs(x-1, y, &g, MOVING, &xf, &yf, &visited);
		//dfs(x+1, y, &g, MOVING, &xf, &yf, &visited);

		//print_char_mat(&g);

		// Go left
		let xl = x - 1;
		while true
		{
			if (g[xl, y+1] == "." or g[xl, y+1] == "|") break;  // found an outlet
			if (g[xl, y  ] == "#") break;  // blocked
			g[xl, y] = MOVING;
			visited[xl, y] = true;
			xl -= 1;
		}
		if (g[xl, y] != "#")
		{
			g[xl, y] = MOVING;
			visited[xl, y] = true;
			dfs(xl, y+1, &g, MOVING, &xf, &yf, &visited);
		}

		// Go right
		let xr = x + 1;
		while true
		{
			if (g[xr, y+1] == "." or g[xr, y+1] == "|") break;
			if (g[xr, y  ] == "#") break;
			g[xr, y] = MOVING;
			visited[xr, y] = true;
			xr += 1;
		}
		if (g[xr, y] != "#")
		{
			g[xr, y] = MOVING;
			visited[xr, y] = true;
			dfs(xr, y+1, &g, MOVING, &xf, &yf, &visited);
		}

		if all(g[[xl,xr], y] == "#")
		{
			g[xl+1: xr, y] = STANDING;

			// Backtrack to point above

			//println("backtracking");
			dfs(x, y-1, &g, MOVING, &xf, &yf, &visited);
		}

	}
	return;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/17");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

