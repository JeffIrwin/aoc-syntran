
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let MOVING   = "|";
let STANDING = "~";

fn part1(): str
{
	let sum_ = 0'i64;

	// First pass: get bounds
	let xmin =  2_000_000_000;
	let ymin =  2_000_000_000;
	let xmax = -2_000_000_000;
	let ymax = -2_000_000_000;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];

			xmin = min(xmin, x);
			xmax = max(xmax, x);

			ymin = min(ymin, y0);
			ymax = max(ymax, y0);
			ymin = min(ymin, y1);
			ymax = max(ymax, y1);
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];

			ymin = min(ymin, y);
			ymax = max(ymax, y);

			xmin = min(xmin, x0);
			xmax = max(xmax, x0);
			xmin = min(xmin, x1);
			xmax = max(xmax, x1);
		}

		str_ = readln(f);
	}
	close(f);

	// Water spring/source
	let xs = 500;
	let ys = 0;

	// Include spring in bounds
	ymin = min(ymin, ys);

	// Pad x (but not y) by 1.  Water may flow one past outer bound before
	// padding
	xmin -= 1;
	xmax += 1;

	// Pad upper bounds because input is inclusive
	xmax += 1;
	ymax += 1;

	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);

	let dx = xmax - xmin;
	let dy = ymax - ymin;

	let g = ["."; dx, dy];

	// Second pass: save

	f = open(filename, "r");
	str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let nums = read_i32s(str_);

		if str_[0] == "x"
		{
			let x  = nums[0];
			let y0 = nums[1];
			let y1 = nums[2];
			g[x - xmin, [y0: y1+1] - ymin] = "#";
		}
		else
		{
			let y  = nums[0];
			let x0 = nums[1];
			let x1 = nums[2];
			g[[x0: x1+1] - xmin, y - ymin] = "#";
		}
		str_ = readln(f);
	}
	close(f);
	print_char_mat(&g);

	////for i in [0: 5]
	//	dfs(xs - xmin, ys + 1 - ymin, &g, MOVING);

	//for i in [0: 8]
	while true
	{
		let g0 = g;
		let x = xs - xmin;  let y = ys + 1 - ymin;
		let xf = x;  let yf = y;
		let visited = [false; dx, dy];
		dfs(x, y, &g, MOVING, &xf, &yf, &visited);
		sum_ = count(g == "|") + count(g == "~");
		println("sum_ = ", sum_);
		println("xf, yf = ", [xf, yf]);

		if (yf < dy-1)
		{
			dfs_standing(xf, yf, &g, STANDING);
		}

		sum_ = count(g == "|") + count(g == "~");
		println("sum_ = ", sum_);
		if all(g == g0)
		{
			// TODO: wierd whitespace issue where this crashes if i remove
			// brackets and one-line both if-statements here
			break;
		}
	}
	print_char_mat(&g);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn dfs_standing(x: i32, y: i32, g: &[str; :, :], char_: str)
{
	//if (g[x,y] != ".") return;
	if (g[x,y] == "#") return;
	if (g[x,y] == "~") return;
	//if (not any(g[x,y] == [".", "|"])) return;

	g[x, y] = char_;
	dfs_standing(x-1, y, &g, char_);
	dfs_standing(x+1, y, &g, char_);

	return;
}

fn dfs(x: i32, y: i32, g: &[str; :, :], char_: str, xf: &i32, yf: &i32, visited: &[bool; :, :])
{
	//if (g[x,y] != ".") return;
	if (g[x,y] == "#") return;
	if (g[x,y] == "~") return;
	//if (not any(g[x,y] == [".", "|"])) return;

	let ny = size(g,1);
	if (y >= ny) return;

	if (visited[x,y]) return;
	visited[x,y] = true;

	xf = x; yf = y;

	// Move down when possible
	let down = true;
	if y < ny-1
		down = any(g[x, y+1] == [".", "|"]);

	if down
	{
		g[x, y] = char_;
		dfs(x, y+1, &g, char_, &xf, &yf, &visited);
	}
	else
	{
		g[x, y] = MOVING;
		dfs(x-1, y, &g, MOVING, &xf, &yf, &visited);
		dfs(x+1, y, &g, MOVING, &xf, &yf, &visited);
	}
	return;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/17");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

