
// Test input
// let INPUT_STR = "+1, -2, +3, +1";

// Real input
let INPUT_STR = "+4
+3
-15
-8
+15
-17
-16
+15
-10
+1
+17
+19
-10
+17
+11
+3
-13
-13
-20
+10
-7
+2
-12
+2
+2
+7
+7
+19
-18
-10
+16
+18
-9
+15
-16
+15
+15
+14
+13
+15
+2
+6
+10
+12
+13
+8
+3
-19
-12
+19
+13
+4
+16
+16
-10
+15
-16
+17
+16
+5
+1
+17
+15
-16
+3
+17
-9
-4
-11
+2
+19
-12
+9
+8
+8
-7
+17
-15
-17
+18
+9
-11
+10
+5
-18
+15
+12
-3
-2
+18
-1
+5
+12
+3
-7
+16
+3
+4
+17
-13
+7
-13
+3
+7
+13
+4
-10
-13
+4
+13
+15
+14
-13
+10
-9
-16
+4
+18
-13
-11
+13
+8
-11
+18
+19
-16
-6
-5
+16
-10
-14
+7
+10
+10
-16
-19
+10
-5
+13
+24
-1
+9
+2
+12
+11
-4
-17
+2
-17
+8
+18
-10
+2
-6
-2
-12
+21
+16
-21
-7
-6
-7
-3
+14
+16
+3
+10
-14
+2
+15
+9
+13
+4
+2
-9
-9
+4
-2
-11
-9
+16
+9
-6
-17
+22
+8
+16
+5
+9
+18
-5
-1
+13
-8
-11
+10
+6
+9
-1
+13
+11
-3
-12
+17
-19
-11
+10
+17
+15
+9
+9
+4
-3
+9
-4
+8
-7
+12
+5
-2
-6
-17
+12
+18
+14
-1
+15
+12
-19
-16
-4
-4
+1
-9
+5
-6
+4
+16
-1
+18
+5
+17
-1
+5
+15
+4
+3
-11
+5
+18
-3
+2
+7
-13
+10
+21
-7
+6
-2
-20
-11
-12
-18
-7
-15
+9
-1
+18
-10
-5
-15
+3
-20
+22
-18
+11
-6
+15
-16
+17
+6
+20
+19
-8
-21
-8
+9
+21
-15
+10
+17
+16
-22
+5
+5
-20
+7
+22
-1
+11
-17
-14
-15
+2
-8
+11
-4
-37
-9
-10
+30
+8
+50
+28
-10
+6
+16
+2
+11
+8
+14
-17
-11
+18
+1
+1
-3
+17
+15
-1
+13
+9
-20
-7
+20
+18
-16
-12
+19
+2
+10
-13
-4
-12
+2
-11
-15
-1
+22
-12
-4
+1
-12
-9
-1
+17
+15
-6
-12
-16
-5
+16
+20
-18
-5
-17
-1
-12
+21
-13
-5
+15
+36
-12
+5
+30
+48
-7
+2
+7
+10
-14
+11
-17
+34
+20
+17
-16
-4
-7
-6
+1
+11
+11
+5
-14
+35
+16
+6
+28
-3
+18
-4
-6
-12
-13
+30
+12
+16
-14
-15
+14
-6
+17
+2
+10
-15
-19
-20
+22
-20
+12
-8
+9
-19
+40
+17
-1
+3
+7
+12
-26
-3
-5
-5
+12
+24
-10
+3
-27
+6
+13
-23
+5
-27
-41
-5
-41
+144
-40
+155
+29
-26
+16
+9
-229
-70
+401
+64265
-10
+19
-3
-14
+10
+2
+13
+13
-19
-18
-11
+16
-19
+10
-2
-7
-12
-13
-16
+19
-12
+14
+2
+15
+17
+14
+19
+8
+14
-7
-16
+11
+15
+9
+11
+5
-8
+16
-11
-16
-14
+10
-13
-13
+8
-3
-23
-19
-18
-3
-7
+18
+5
-2
+13
+10
-8
-16
+22
-9
+18
+7
+22
-3
-17
+11
+11
+12
+11
+7
+16
+12
+2
-16
-8
+15
+8
-4
+2
-4
+12
-18
+15
-17
-20
+18
-1
+6
-22
+23
+19
+3
+15
-17
-2
+7
+1
-12
-7
-15
-4
+15
-13
+11
+14
+16
+19
+7
-3
-10
+12
-22
+6
-2
-14
+18
-1
+27
+13
+15
+10
+18
+10
+11
-13
+11
-1
+7
+3
-2
+14
-8
-2
+9
-16
+13
+7
+19
-15
+3
+9
+14
-8
+13
+19
-10
-6
-4
+7
+6
-1
-6
-4
-16
+1
+18
+17
+1
+16
+17
-19
+12
+21
+10
+7
+3
-9
-9
+11
+17
+5
+13
+2
+15
-6
-18
+14
+17
-2
-12
-14
+1
-18
-1
-12
-13
+7
+14
+14
-18
+1
+19
-9
-17
-15
-14
-12
-20
+12
-8
+1
+8
+11
+6
+8
+10
-9
-6
+20
+5
+14
-17
-13
+22
+13
+3
+11
+19
-1
-9
-5
-22
+19
+20
-16
+6
+15
-2
+31
+12
+3
+4
+24
+16
-6
+11
-20
+18
+8
-9
-9
+28
-4
-3
-17
-9
-11
-1
+15
+13
+12
-30
-16
+19
-22
+2
-18
+7
-8
-24
+31
+5
+36
+3
+48
+10
+19
-7
-11
+5
+3
+7
+4
-15
+13
+10
-7
+14
+9
+7
+11
+12
-3
+6
-17
+7
-15
-10
+17
-4
-17
-13
+18
-3
-9
+5
+10
-12
-1
+15
+20
-3
-1
-1
-6
+15
-2
+13
+19
-1
+8
+17
+4
+1
+18
+1
+4
+12
+3
-5
-21
-15
-14
+20
+5
+18
-6
-5
-5
+4
-10
+18
-5
+23
+22
+13
-5
+15
+15
-14
-15
+7
-11
-8
-2
-6
-9
-15
-3
+12
+25
-9
-15
-16
+20
+13
+25
-6
+10
+7
+15
-16
+15
-9
-21
+13
+14
+6
-16
+17
-27
-21
+12
+26
+13
+5
-23
+16
+9
+20
+14
-32
+27
-2
-16
+21
-92
-12
-14
-25
+4
-21
-9
-14
-14
-6
+8
+5
+2
-1
-3
+15
+13
+2
-19
-15
+11
+14
-4
-18
+23
-24
-14
+17
-10
+1
+14
-19
-18
-11
-10
-13
+8
+21
-4
-4
+11
-17
-13
-23
-9
+14
+14
-20
-17
+11
-18
-19
-64
+9
-24
-16
-10
+196
+16
-5
+21
-7
+28
+5
+5
-19
+38
-33
+25
+209
+391
-559
+64522
-2
-19
+7
+17
+5
-6
+18
-2
+5
+4
-11
-17
+14
+12
-19
-9
+14
+20
-16
-6
+12
+15
+11
+15
+24
-37
+12
-15
-4
+3
-21
-17
-19
-16
+21
+12
+9
-13
-20
-30
-7
+10
+14
-3
+20
+11
-1
+9
-22
-19
-3
-8
+3
-18
+8
+3
-7
-2
-7
+6
+15
-19
+13
-26
+7
-18
-13
+21
-9
+10
-130255";

//// Other test input strings
//INPUT_STR = "+1, -1";
//INPUT_STR = "+3, +3, +4, -2, -4";
//INPUT_STR = "-6, +3, +8, +5, -6";
//INPUT_STR = "+7, +7, -2, -7, -4";

//=================================================================
//
// This gigantic block is from "utils.syntran".  I would just include it if I wasn't running from the syntran explorer web-based editor
//
// #include("../../utils.syntran");

//==============================================================================
// START UTILS BLOCK
//==============================================================================

let digit_chars = "0123456789";
let hex_chars = digit_chars + "abcdef";

//==============================================================================

fn countln_(filename: str): i32
{
	let nlines = 0;

	let f = open(filename);
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);
		nlines += 1;

		str_ = readln(f);
	}
	close(f);

	return nlines;
}

//==============================================================================

fn scan(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic scan()

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = i64(0);
	while not found and i < len(str_)
	{

		let j = 0;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	if (found)
		i -= 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn scanback(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic scan() with back = true

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = len(str_) - 1;
	while not found and i >= 0
	{

		let j = i64(0);
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i -= 1;
	}
	//println("found = ", found);

	if (found)
		i += 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn verify(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic verify()

	//println("starting verify()");
	//println("str_ = """, str_, """");
	//println("set = ", set);

	let found = true;
	let i = i64(0);
	while found and i < len(str_)
	{
		//println(i);

		let j = 0;
		found = false;
		while not found and j < len(set)
		{
			//found = str_[i] != set[j];
			//found = not (str_[i] == set[j]);
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	if (not found)
		i -= 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn tok_i32(str_: str): [i64; :]
{
	// tokenize a string into the first int contained within it, then return the
	// substring start index, end index, and length

	//println("starting tok_i32()");
	//println("str_ = """, str_, """");

	let nums = "1234567890";
	let beg_ = scan    (str_, nums);
	//println("beg_ = ", beg_);

	let n = len(str_);
	//println("n = ", n);

	// nasty bug which was just fixed
	let len_ = i64(-1);
	if (beg_ >= 0)
		len_ = verify(str_[beg_:n], nums);
	//println("len_ = ", len_);

	let end_ = i64(-1);
	if (beg_ < 0)
	{
		//println("no beg_");
	}
	else if (len_ < 0)
	{
		// This is consistent with the way that verify() works in Fortran
		end_ = n - 1;
		len_ = end_ - beg_ + 1;
	}
	else
		end_ = beg_ + len_ - 1;

	//println("beg_ = ", beg_);
	//println("end_ = ", end_);

	//println("num beg = ", str_[beg_]);
	//println("num end = ", str_[end_]);
	//println("num str = ", str_[beg_: end_+1]);

	return [beg_, end_, len_];
}

//==========================================================

fn read_i32(str_: str): i32
{
	let toks = tok_i32(str_);

	// multiple return vals are packed into a vec bc i don't have structs :sad:
	let beg_ = toks[0];
	let end_ = toks[1];
	//let len_ = toks[2]; // not needed

	//println("read_i32 substr = ", str_[beg_: end_+1]);

	let ans = parse_i32(str_[beg_: end_+1]);
	//println("read_i32 = ", ans);

	return ans;
}

fn read_i32s(str_: str): [i32; :]
{
	// Parse a vector of i32 integers from a string.  Any non-int characters are
	// treated as delimiters

	let i = i64(0);
	let n = len(str_);

	//println("str_ = ", str_);
	//println("n = ", n);

	//let toks = i64([0, 0, 0]);
	let toks = [i64(0); 3];
	let num_nums = 0;  // the number of numbers

	while toks[0] >= 0
	{
		//println("i = ", i);
		toks = tok_i32(str_[i:n]);
		//println("toks = ", toks);
		//println("num = ", num);
		num_nums += 1;
		i += toks[1] + 1;
	}
	num_nums -= 1;

	let nums = [0; num_nums];
	i = i64(0);
	for j in [0: num_nums]
	{
		//println("i = ", i);
		toks = tok_i32(str_[i:n]);
		//println("toks = ", toks);
		let num = parse_i32(str_[i + toks[0]: i + toks[1]+1]);
		//println("num = ", num);
		nums[j] = num;
		//num_nums += 1;
		i += toks[1] + 1;
	}

	return nums;
}


//==============================================================================

fn verifyback(str_: str, set: str): i64
{
	//println("");
	//println("starting verifyback");
	//println("str_ = ", str_);
	//println("set  = ", set);

	let i = len(str_) - 1;
	let found = true;
	while found and i >= 0
	{
		let j = 0;
		found = false;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i -= 1;
	}

	let ans = i64(-1);
	if not found
	{
		//println("ans = ", i + 1);
		ans = i + 1;
	}
	return ans;
}

//==============================================================================

//==============================================================================

fn is_digit(char_: str): bool
{
	// TODO: optimize with i32() char casting, like is_alpha()
	return scan(char_, digit_chars) >= 0;
}

fn is_alpha(char_: str): bool
{
	return
		(i32("a") <= i32(char_) and i32(char_) <= i32("z")) or
		(i32("A") <= i32(char_) and i32(char_) <= i32("Z"));
}

//==============================================================================

// TODO: rename to any_char_eq_str or any_char_eq_set
fn any_str_eq_set(str_: str, set: str): bool
{
	return scan(str_, set) >= 0;
}

//==============================================================================

fn any_mat(v: [bool; :, :]): bool
{
	let found = false;
	let i = 0;
	while i < size(v, 1) and not found
	{
		let j = 0;
		while j < size(v, 0) and not found
		{
			found = v[j,i];
			j += 1;
		}
		i += 1;
	}
	return found;
}

//==============================================================================

fn any_r3(v: [bool; :, :, :]): bool
{
	let found = false;
	let i = 0;
	while i < size(v, 2) and not found
	{
		let j = 0;
		while j < size(v, 1) and not found
		{
			let k = 0;
			while k < size(v, 0) and not found
			{
				found = v[k,j,i];
				k += 1;
			}
			j += 1;
		}
		i += 1;
	}
	return found;
}

//==============================================================================

fn minloc_mat(dist: [i32; :, :], q: [bool; :, :]): [i32; :]
{
	let found = false;
	let min_ = -1;
	let minloc_ = [-1, -1];
	for y in [0: size(dist,1)]
	for x in [0: size(dist,0)]
	{
		if q[x,y]
		{
			if found
			{
				//min_ = min(min_, dist[x,y]);
				if (dist[x,y] < min_)
				{
					min_ = dist[x,y];
					minloc_ = [x, y];
				}
			}
			else
			{
				found = true;
				min_ = dist[x,y];
				minloc_ = [x, y];
			}
		}
	}
	//let ans = min_;
	return minloc_;
}

//==============================================================================

fn minloc_r3(dist: [i32; :, :, :], q: [bool; :, :, :]): [i32; :]
{
	let found = false;
	let min_ = -1;
	let minloc_ = [-1, -1];
	for z in [0: size(dist,2)]
	for y in [0: size(dist,1)]
	for x in [0: size(dist,0)]
	{
		if q[x,y,z]
		{
			if found
			{
				if (dist[x,y,z] < min_)
				{
					min_ = dist[x,y,z];
					minloc_ = [x, y, z];
				}
			}
			else
			{
				found = true;
				min_ = dist[x,y,z];
				minloc_ = [x, y, z];
			}
		}
	}
	//let ans = min_;
	return minloc_;
}

//==============================================================================

// TODO: rename to any_str_eq_vec
fn any_str_eq(str_: str, v: [str; :]): bool
{
	//if (any_str_eq(my_num, wn_nums_str)) nwin = 1;

	let found = false;
	let i = 0;
	while i < size(v, 0) and not found
	{
		found = str_ == v[i];
		i += 1;
	}
	return found;
}

//==============================================================================

fn index_(str_: str, substr: str): i64
{
	//println("str_   = ", str_);
	//println("substr = ", substr);

	let nsub = len(substr);

	let i = i64(0);
	let found = false;
	while not found and i < len(str_) - len(substr) + 1
	{

		found = str_[i: i+nsub] == substr;

		////println("i = ", i);
		//let j = 0;
		//found = true;
		//while found and j < len(substr)
		//{
		//	//println("j = ", j);
		//	found = str_[i+j] == substr[j];
		//	j += 1;
		//}

		i += 1;
		//i = i + 1;
	}

	if found
	{
		i -= 1;
		//println("str_ = ", str_);
		//println("str_[] = ", str_[i: i + len(substr)]);
		//println("substr = ", substr);
		//println();
		return i;
	}
	else
	{
		//println("not found");
		return i64(-1);
	}
}

//==============================================================================

fn indexback(str_: str, substr: str): i64
{
	//println("str_   = ", str_);
	//println("substr = ", substr);

	let nsub = len(substr);

	let i = len(str_) - len(substr);
	let found = false;
	while not found and i >= 0
	{

		found = str_[i: i+nsub] == substr;

		////println("i = ", i);
		//let j = 0;
		//found = true;
		//while found and j < len(substr)
		//{
		//	//println("j = ", j);
		//	found = str_[i+j] == substr[j];
		//	j += 1;
		//}
		i -= 1;
	}

	if found
	{
		i += 1;
		//println("str_ = ", str_);
		//println("str_[] = ", str_[i: i + len(substr)]);
		//println("substr = ", substr);
		//println();
		return i;
	}
	else
	{
		//println("not found");
		return i64(-1);
	}
}

//==============================================================================

fn split_(str_: str, delims: str): [str; :]
{
	// Split an input str_ into a vector of strs based on a set of delimiters

	//println("starting split_()");
	//println("str_ = """, str_, """");

	let n = len(str_);
	//println("n = ", n);

	let nout = 0;
	if (any_str_eq_set(str_[0], delims)) nout -= 1;

	// First pass: count delimited strings
	let i = 0;
	while i < n
	{
		//println("i = ", i);
		let i0 = i;

		i = scan  (str_[i:n], delims) + i0;
		if (i < i0) i = n;

		i0 = i;
		i = verify(str_[i:n], delims) + i0;
		if (i < i0) i = n;
		//i += 1;

		nout += 1;
	}
	//println("nout = ", nout);

	let out = [""; nout];

	nout = 0;
	if (any_str_eq_set(str_[0], delims)) nout -= 1;

	// Second pass: save split strings
	i = 0;
	while i < n
	{
		//println("i = ", i);
		let i0 = i;

		i = scan  (str_[i:n], delims) + i0;
		if (i < i0) i = n;

		if (nout >= 0) out[nout] = str_[i0: i];

		i0 = i;
		i = verify(str_[i:n], delims) + i0;
		if (i < i0) i = n;
		//i += 1;

		nout += 1;
	}
	return out;
}

//==============================================================================

fn parse_i32_hex(str_: str): i32
{
	// Read a hexadecimal number *without* any leading `0x` or `#` or anything
	// besides literal hex characters

	let num = 0;
	for ii in [0: len(str_)]
	{
		let i = len(str_) - ii - 1;
		let c = str_[i];
		let val = scan(hex_chars, c);
		num += i32(val * 16 ** ii);
	}
	return num;
}

//==============================================================================

fn parse_i32_delim(str_: str, delims: str): [i32; :]
{
	let str_vec = split_(str_, delims);
	//println("str_vec = ", str_vec);
	let vec = [i32(0); size(str_vec, 0)];
	for i in [0: size(str_vec, 0)]
		vec[i] = parse_i32(str_vec[i]);
	return vec;
}

//==============================================================================

fn parse_i64_delim(str_: str, delims: str): [i64; :]
{
	let str_vec = split_(str_, delims);
	//println("str_vec = ", str_vec);
	let vec = [i64(0); size(str_vec, 0)];
	for i in [0: size(str_vec, 0)]
		vec[i] = parse_i64(str_vec[i]);
	return vec;
}

//==============================================================================

fn rm_char(str_: str, char_: str): str
{
	// Remove all occurences of a char from a str

	// allocate to max possible length
	let out = str_;

	let j = 0;
	for i in [0: len(str_)]
	{
		if not (str_[i] == char_)
		{
			out[j] = str_[i];
			j += 1;
		}
	}

	// trim
	return out[0: j];
}

fn reverse_str(str_: str): str
{
	// Reverse a str
	let rev = str_;
	let n = len(str_);
	for i in [0: n]
		rev[i] = str_[n-i-1];
	return rev;
}

//==============================================================================

fn ends_with_(str_: str, char_: str): bool
{
	return str_[ len(str_) - 1 ] == char_;
}

fn all_ends_with_(strs: [str; :], j: [i32; :], char_: str): bool
{
	let i = 0;
	let all_end = true;
	while all_end and i < size(j, 0)
	{
		all_end = ends_with_(strs[j[i]], char_);
		i += 1;
	}
	return all_end;
}

//==============================================================================

fn gcd64(a: i64, b: i64): i64
{
	// Euclidean algorithm for GCD
	while b != 0
	{
		let t = b;
		b = a % b;
		a = t;
	}
	return a;
}

fn lcm64(a: i64, b: i64): i64
{
	let abs_ = a * b;
	if (abs_ < 0) abs_ = -abs_;
	return abs_ / gcd64(a, b);
}

fn abs_i32(a: i32): i32
{
	let abs_ = a;
	if (abs_ < 0) abs_ = -abs_;
	return abs_;
}

//==============================================================================

fn sign_(x: i32): i32
{
	let s = 0;
	if x > 0
		s = +1;
	else if x < 0
		s = -1;
	return s;
}

fn sign_64(x: i64): i64
{
	let s = i64(0);
	if x > 0
		s = +i64(1);
	else if x < 0
		s = -i64(1);
	return s;
}

//==============================================================================

fn sum_i32(v: [i32; :]): i32
{
	let sum_ = 0;
	for i in [0: size(v,0)]
		sum_ += v[i];
	return sum_;
}

//==============================================================================

fn pmod(i: i32, n: i32): i32
{
	// Modulo/remainder but always positive
	//
	// TODO: this is actually wrong
	return (i % n + n) % n;
}

//==============================================================================
// END UTILS BLOCK
//==============================================================================

fn part1(): i32
{
    println("starting part 1");

    // This string would get read from a file in any normal non-web implementation
    let str_ = INPUT_STR;

    let NEWLINE = char(10);
    let numbers = parse_i32_delim(str_, "," + NEWLINE);

    //println("numbers = ", numbers);
    //println("numbers[0:10] = ", numbers[0: min(10'i64, size(numbers, 0))]);

    let sum_ = sum(numbers);

    //// Last year you would've had to sum manually
    // let sum_ = 0;
    // for i in [0: size(numbers, 0)]
    //     sum_ += numbers[i];

    println("part 1 = ", sum_);

    return 0;
}

fn part2(): i32
{
    println("starting part 2");

    // This string would get read from a file in any normal non-web implementation
    let str_ = INPUT_STR;

    let NEWLINE = char(10);
    let numbers = parse_i32_delim(str_, "," + NEWLINE);

    //println("numbers = ", numbers);
    //println("numbers[0:10] = ", numbers[0: min(10'i64, size(numbers, 0))]);

    // let sum_ = sum(numbers);
    let num_numbers = size(numbers, 0);

    // abs() doesn't work for ints yet, so do some hacky casting :(
    let NMAX = i64(1.1 * sum(abs(1.0 * numbers)));
    //let NMAX = 1_000_000;

    let NMAX2 = 2 * NMAX;
    let hist = [0; NMAX2];
    let cumsum = 0;

    let i = 0;
    let found = false;
    while not found
    {
        //println("i = ", i);
        cumsum += numbers[i % num_numbers];

        //cumsums[i] = cumsum; // brute force

        // Shift pigeonhole index by NMAX because the cumsum could be negative
        let idx = cumsum + NMAX;

        if (idx >= NMAX2)
        {
            println("Error: histogram overflow.  Increase NMAX and re-run");
            exit(-1);
        }

        // hist is a histogram of cumsums that we have seen so far
        hist[idx] += 1;
        found = hist[idx] >= 2;

        //// Brute force.  Too slow for real input
        //let j = 0;
        //while not found and j < i - 1
        //{
        //    found = cumsum == cumsums[j];
        //    j += 1;
        //}

        i += 1;
    }

    //println("i = ", i);
    //println("cumsum = ", cumsum);

    println("part 2 = ", cumsum);

    return 0;
}

fn main(): i32
{
    println("starting aoc main");
    let p1 = part1();
    let p2 = part2();
    println("ending aoc main");
    return 0;
}

return main();

