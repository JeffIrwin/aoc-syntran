
#include("../../utils.syntran");
#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let n = countln_(filename);
	let pos = [0; 3, n];
	let range = [0; n];

	let f = open(filename, "r");
	for i in [0: n]
	{
		let nums = read_mi32s(readln(f));
		pos[:,i] = nums[0: 3];
		range[i] = nums[3];
	}
	close(f);

	let rmax = -1;
	let imax = -1;
	for i in [0: n]
		if range[i] > rmax
		{
			rmax = range[i];
			imax = i;
		}
	println("imax, rmax = ", [imax, rmax]);

	let pmax = pos[:, imax];
	let sum_ = 0'i64;
	for i in [0: n]
	{
		if sum(abs(pos[:,i] - pmax)) <= rmax
			sum_ += 1;
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let n = countln_(filename);
	let pos = [0; 3, n];
	let range = [0; n];

	let f = open(filename, "r");
	for i in [0: n]
	{
		let nums = read_mi32s(readln(f));
		pos[:,i] = nums[0: 3];
		range[i] = nums[3];
	}
	close(f);

	let xmin = minval(pos[0,:]);
	let ymin = minval(pos[1,:]);
	let zmin = minval(pos[2,:]);
	let xmax = maxval(pos[0,:]) + 1;
	let ymax = maxval(pos[1,:]) + 1;
	let zmax = maxval(pos[2,:]) + 1;
	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);
	println("z in ", [zmin, zmax]);

	let nx = xmax - xmin;
	let ny = ymax - ymin;
	let nz = zmax - zmin;

	let sum_ = 0'i64;

	//
	// TODO: solve this like an optimization problem.  Start with some point,
	// maybe the middle of the bounding box or the weighted centroid.  Count the
	// number of particles in range, then do the same for its neighbors.
	// Advance to any neighbor that is in range of more.  Might have to search
	// more than 1 step as immediate neighbors could be in range of the same
	// number
	//
	// Actually, start point should probably be the part 1 solution to avoid
	// getting stuck in local minima.  Or maybe need to re-try optimization with
	// each particle as the initial guess
	//

	// Number of particles `ns` within range of each point
	let ns = new_dict_i64();
	//let ns = [0; nx, ny, nz];

	for i in [0: n]
	{
		println("i = ", i);
		let xi = pos[0,i];
		let yi = pos[1,i];
		let zi = pos[2,i];
		let ri = range[i];

		for dz in [-ri: ri+1]
		{
			let z = zi + dz;
			if (z < zmin) continue;
			if (z >= zmax) continue;
			for dy in [-ri + abs(dz): ri - abs(dz) + 1]
			{
				let y = yi + dy;
				if (y < ymin) continue;
				if (y >= ymax) continue;
				for dx in [-ri + abs(dz) + abs(dy): ri - abs(dz) - abs(dy) + 1]
				{
					let x = xi + dx;
					if (x < xmin) continue;
					if (x >= xmax) continue;

					//ns[x-xmin, y-ymin, z-zmin] += 1;

					let key = str([x-xmin, y-ymin, z-zmin]);
					let n0 = get_dict_i64(&ns, key);
					if (n0 < 0) n0 = 0;
					set_dict_i64(&ns, key, n0+1);
				}
			}
		}
	}

	let nmax = -1;
	for key in keys_dict_i64(&ns)
	{
		let val = get_dict_i64(&ns, key);
		//println("key, val = ", key, ", ", val);

		if val > nmax
		{
			nmax = val;
			sum_ = sum(abs(read_mi32s(key) + [xmin, ymin, zmin]));
		}
		else if val == nmax
		{
			let s = sum(abs(read_mi32s(key) + [xmin, ymin, zmin]));
			if s < sum_
				sum_ = s;
		}
	}

	//let nmax = -1;
	//for z in [zmin: zmax]
	//for y in [ymin: ymax]
	//for x in [xmin: xmax]
	//{
	//	if ns[x-xmin, y-ymin, z-zmin] > nmax
	//	{
	//		nmax = ns[x-xmin, y-ymin, z-zmin];
	//		sum_ = sum(abs([x, y, z]));
	//	}
	//}

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2018/23");

	let p1 = ""; let p2 = "";

	//p1 = part1(); // TODO
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

