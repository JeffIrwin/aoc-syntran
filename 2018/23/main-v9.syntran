
#include("../../utils.syntran");
#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let n = countln_(filename);
	let pos = [0; 3, n];
	let range = [0; n];

	let f = open(filename, "r");
	for i in [0: n]
	{
		let nums = read_mi32s(readln(f));
		pos[:,i] = nums[0: 3];
		range[i] = nums[3];
	}
	close(f);

	let rmax = -1;
	let imax = -1;
	for i in [0: n]
		if range[i] > rmax
		{
			rmax = range[i];
			imax = i;
		}
	println("imax, rmax = ", [imax, rmax]);

	let pmax = pos[:, imax];
	let sum_ = 0'i64;
	for i in [0: n]
	{
		if sum(abs(pos[:,i] - pmax)) <= rmax
			sum_ += 1;
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

// 6 cardinal directions in 3d
let NDIRS = 6;
let DIRS =
[
	-1,  0,  0,
	+1,  0,  0,
	 0, -1,  0,
	 0, +1,  0,
	 0,  0, -1,
	 0,  0, +1
	;
	3, NDIRS
];

fn count_particles(u: &[i32; :], pos: &[i32; :,:], range: &[i32; :]): i32
{
	// Count number of particles that are within range of position `u`
	let nu = 0;
	for i in [0: size(range, 0)]
		if sum(abs(u - pos[:,i])) <= range[i]
			nu += 1;
	return nu;
}

fn part2(): str
{
	let n = countln_(filename);
	let pos = [0; 3, n];
	let range = [0; n];

	let f = open(filename, "r");
	for i in [0: n]
	{
		let nums = read_mi32s(readln(f));
		pos[:,i] = nums[0: 3];
		range[i] = nums[3];
	}
	close(f);

	let xmin = minval(pos[0,:]);
	let ymin = minval(pos[1,:]);
	let zmin = minval(pos[2,:]);
	let xmax = maxval(pos[0,:]) + 1;
	let ymax = maxval(pos[1,:]) + 1;
	let zmax = maxval(pos[2,:]) + 1;
	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);
	println("z in ", [zmin, zmax]);

	let nx = xmax - xmin;
	let ny = ymax - ymin;
	let nz = zmax - zmin;

	println("DIRS = ", DIRS);

	let maxnp = 0;
	let imax = 0;
	for i in [0: n]
	{
		let p = pos[:,i];
		let np = count_particles(&p, &pos, &range);
		if np > maxnp
		{
			maxnp = np;
			imax = i;
		}
		//println("i, np = ", [i, np]);
	}
	println("imax, maxnp = ", [imax, maxnp]);
	//exit(0);

	let visited = new_dict_i64();

	let QCAP = 1024 ;//* 1024;
	let q = [-1; 4, QCAP];
	let qs = 0;  let qe = 0;

	//let p0 = pos[:,0];
	//let p0 = pos[:,3];  // nu = 855, part 2 = 31371821

	//let p0 = pos[:,4];  // nu = 891, part 2 = 42614055
	//let p0 = [22793219, 10301168, 10308148];
	//let p0 = [22782019, 10200068, 10207048];  // nu >= 912
	let p0 = [22781816, 10986500, 10469192];  // 912

	//let p0 = pos[:,6];
	//let p0 = pos[:, 933];

	//let p0 = [xmin, ymin, zmin];
	//let p0 = ([xmin, ymin, zmin] + [xmax, ymax, zmax]) / 2;  

	let n0 = count_particles(&p0, &pos, &range);

	// Push
	q[:, qe] = [p0, [n0]];  qe += 1;

	//q[:, qe] = pos[:,0];  qe += 1;
	//q[:, qe] = pos[:,1];  qe += 1;

	// Known from previous run
	//q[:, qe] = [3389314, -11692848, 5912660];  qe += 1;

	//q[:, qe] = [xmin, ymin, zmin];  qe += 1;
	//q[:, qe] = ([xmin, ymin, zmin] + [xmax, ymax, zmax]) / 2;  qe += 1;

	// Bisection
	let po = [0, 0, 0];  // origin
	let pr = p0;         // point in range of most particles
	let npr = count_particles(&pr, &pos, &range);
	while true
	{
		if (all(po == pr)) break;

		let pm = (po + pr) / 2;  // midpoint
		let npm = count_particles(&pm, &pos, &range);

		let done_ = all(pm == po) or all(pm == pr);
		if npm < npr
		{
			po = pm;
		}
		else
		{
			//println("npm = ", npm);
			//println("pm = ", pm);
			println("sum abs = ", sum(abs(pm)));
			pr = pm;
		}
		if (done_) break;
	}
	println("pr = ", pr);
	let sum_ = sum(abs(pr));
	println("npr  = ", npr);
	println("sum_ = ", sum_);
	//exit(0);

	// BFS towards the origin while maintaining particles in range
	sum_ = 2_000_000_000;
	let smin = sum_;
	//qs = qe;
	while qs != qe
	{
		// Pop
		let qu = q[:, qs];  qs = (qs+1) % QCAP;

		// Unpack
		let u = qu[0: 3];
		let nu = qu[3];

		//let key = str(u);

		let su = sum(abs(u));
		if (su > smin) continue;
		if (su < sum_) println("su = ", su);
		sum_ = su;

		for d in [0: NDIRS]
		{
			let v = u + DIRS[:,d];
			let sv = sum(abs(v));
			if (sv > su) continue;
			let nv = count_particles(&v, &pos, &range);
			if (nv < nu) continue;

			let step = 1;
			while true
			{
				let v0 = v;  let sv0 = sv;  let nv0 = nv;
				v = u + step * DIRS[:,d];
				sv = sum(abs(v));
				nv = count_particles(&v, &pos, &range);
				if (sv > su or nv < nu)
				{
					//println("sv > su = ", sv > su);
					//println("nv < nu = ", nv < nu);
					//println("nv, nu = ", [nv, nu]);
					v = v0;
					nv = nv0;
					sv = sv0;
					break;
				}
				step *= 2;
				if (step < 0) break;
			}
			//println("step = ", step);

			smin = min(smin, sv);
			if (nv < nu) continue;

			// Push
			q[:, qe] = [v, [nv]];  qe = (qe+1) % QCAP;
			if qe == qs
			{
				println("Error:  queue overflow!");
				exit(-3);
			}
		}
	}

	// Uphill BFS towards points in range of more particles
	let nmax = -1;
	let nvmax = -1;
	qs = qe;
	while qs != qe
	{
		// Pop
		let qu = q[:, qs];  qs = (qs+1) % QCAP;

		// Unpack
		let u = qu[0: 3];
		let nu = qu[3];

		//if (not in_bounds([xmin, ymin, zmin], u, [xmax, ymax, zmax])) continue;

		let key = str(u);
		let seen = get_dict_i64(&visited, key);
		if (seen == 1) continue;
		set_dict_i64(&visited, key, 1'i64);

		//let nu = count_particles(&u, &pos, &range);

		//// TODO: might need another search after finding the optimum `nu` to
		//// then step towards the closest equivalent point towards the origin

		//if (nu < nmax) continue;
		if (nu < nvmax) continue;

		let s = sum(abs(u));

		//println("u = ", u);
		if (nu > nmax)
		{
			//println("s = ", s);
			println("nu = ", nu);
			sum_ = s;
		}
		//nmax = nu;
		nmax = max(nmax, nu);
		sum_ = min(sum_, s);

		println("u, nu = ", [u, [nu]]);

		//let nvmax = nmax;
		nvmax = max(nvmax, nmax);

		if (nu >= 912) break;

		for d in [0: NDIRS]
		{
			let step = 1;
			let nv = 0;
			let v = u;
			while true
			{
				let v0 = v;  let nv0 = nv;
				v = u + step * DIRS[:,d];
				//if (not in_bounds([xmin, ymin, zmin], v, [xmax, ymax, zmax])) break;
				nv = count_particles(&v, &pos, &range);

				if (nv < nu)
				{
					v = v0;
					nv = nv0;
					break;
				}

				step *= 2;
				if (step < 0) break;
				if (nv != nu) break;
			}
			//if (nv < nu) continue;

			nvmax = max(nvmax, nv);

			if (nv < nvmax) continue;

			//if (nv > nu) println("v, nv = ", [v, [nv, nmax, nvmax]]);
			//if (nv > nu) println("v, nv = ", [v, [nv]]);

			// Push
			q[:, qe] = [v, [nv]];  qe = (qe+1) % QCAP;
			if qe == qs
			{
				println("Error:  queue overflow!");
				exit(-3);
			}
		}
	}

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2018/23");

	let p1 = ""; let p2 = "";

	//p1 = part1(); // TODO
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

