
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let g = read_char_mat(filename);
	//println("g = ");
	//print_char_mat(&g);

	let nx = size(g, 0);
	let ny = size(g, 1);
	let bg = [false; nx, ny];

	let nsplit = 0;
	for y in [1: ny]
	for x in [0: nx]
	{
		if any(g[x, y-1] == ["S", "|"])
		{
			bg[x,y] = true;
			if (g[x,y] == ".") g[x,y] = "|";
		}

		if x-1 >= 0
			if g[x-1, y] == "^"
				if g[x-1, y-1] == "|"
				{
					nsplit += 1;  // only count one side of the splits
					bg[x,y] = true;
					if (g[x,y] == ".") g[x,y] = "|";
				}
		if x+1 < nx
			if g[x+1, y] == "^"
				if g[x+1, y-1] == "|"
				{
					bg[x,y] = true;
					if (g[x,y] == ".") g[x,y] = "|";
				}
	}
	//println("x0, y0 = ", [x0, y0]);

	//println("g = ");
	//print_char_mat(&g);

	sum_ = nsplit;

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let g = read_char_mat(filename);
	//println("g = ");
	//print_char_mat(&g);

	let nx = size(g, 0);
	let ny = size(g, 1);

	// Integer grid counting how many timelines can get to a location
	let ig = [0'i64; nx, ny];
	let bg = [false; nx, ny];

	// I do two passes here for the marking first and then the counting, but I
	// think it could be done in just one pass

	for y in [1: ny]
	for x in [0: nx]
	{
		if any(g[x, y-1] == ["S", "|"])
		{
			bg[x,y] = true;
			if (g[x,y] == ".") g[x,y] = "|";
		}

		if x-1 >= 0
			if g[x-1, y] == "^"
				if g[x-1, y-1] == "|"
				{
					bg[x,y] = true;
					if (g[x,y] == ".") g[x,y] = "|";
				}
		if x+1 < nx
			if g[x+1, y] == "^"
				if g[x+1, y-1] == "|"
				{
					bg[x,y] = true;
					if (g[x,y] == ".") g[x,y] = "|";
				}
	}

	//println("g = ");
	//print_char_mat(&g);
	//println("bg = ", bg);

	for y in [1: ny]
	for x in [0: nx]
	{
		if (not bg[x,y]) continue;  // skip unvisited
		if (g[x, y-1] == "S") ig[x, y-1] = 1;  // mark start

		ig[x, y] = ig[x, y-1];  // start with upward parent's count
		if (x-1 >= 0)
			if g[x-1, y] == "^"
				ig[x, y] += ig[x-1, y-1];
		if (x+1 < nx)
			if g[x+1, y] == "^"
				ig[x, y] += ig[x+1, y-1];
	}
	//println("ig = ", ig);
	sum_ = sum(ig[:, ny-1]);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/7");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

