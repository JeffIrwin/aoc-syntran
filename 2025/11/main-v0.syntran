
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");
#include("../../dict_str.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let map = new_dict_str();

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		let chunks = split_(str_, ":");
		let node = chunks[0];
		let children = chunks[1];
		set_dict_str(&map, node, children);

		//let nodes = split_(str_, ": ");
		//println("nodes = ", nodes);

		////let node = nodes[0];
		////let children = get_dict_str(&map, node);
		//for child in nodes[1: size(nodes,0)]
		//	set_dict_str(&map, nodes[0], child);

		str_ = readln(f);
	}
	close(f);
	println("keys = ", keys_dict_str(&map));
	println("vals = ", vals_dict_str(&map));  // hard to read, no quotes

	let node = "you";
	let dest = "out";
	let npaths = 0;
	search(&map, node, dest, &npaths);

	sum_ = npaths;

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let map = new_dict_str();

	let f = open(filename, "r");
	//f = open("test-input2.txt", "r"); // TODO

	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);
		let chunks = split_(str_, ":");
		let node = chunks[0];
		let children = chunks[1];
		set_dict_str(&map, node, children);
		str_ = readln(f);
	}
	close(f);
	println("keys = ", keys_dict_str(&map));
	println("vals = ", vals_dict_str(&map));  // hard to read, no quotes

	let node = "svr";
	let dest = "out";
	let seen_dac = false;
	let seen_fft = false;
	let npaths = 0;
	search2(&map, node, dest, &npaths, seen_dac, seen_fft);

	sum_ = npaths;

	println("part 2 = ", sum_);
	return str(sum_);
}

fn search2(map: &dict_str, node: str, dest: str, npaths: &i32, seen_dac: bool, seen_fft: bool)
{
	if node == dest and seen_dac and seen_fft
		npaths += 1;
	if node == "dac"
		seen_dac = true;
	if node == "fft"
		seen_fft = true;

	// DFS
	let children = get_dict_str(&map, node);
	//println("children = ", children);

	for child in split_(children, " ")
	{
		//println("child = ", child);
		search2(&map, child, dest, &npaths, seen_dac, seen_fft);
	}

	return;
}

fn search(map: &dict_str, node: str, dest: str, npaths: &i32)
{
	if node == dest
		npaths += 1;

	// DFS
	let children = get_dict_str(&map, node);
	//println("children = ", children);

	for child in split_(children, " ")
	{
		//println("child = ", child);
		search(&map, child, dest, &npaths);
	}

	return;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/11");

	let p1 = ""; let p2 = "";

	//p1 = part1(); // TODO
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

