
#include("../../utils.syntran");
#include("../../dict_i64.syntran");
#include("../../dict_str.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let map = new_dict_str();

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let chunks = split_(str_, ":");
		let node = chunks[0];
		let children = chunks[1];
		set_dict_str(&map, node, children);

		//let nodes = split_(str_, ": ");
		//println("nodes = ", nodes);

		////let node = nodes[0];
		////let children = get_dict_str(&map, node);
		//for child in nodes[1: size(nodes,0)]
		//	set_dict_str(&map, nodes[0], child);

		str_ = readln(f);
	}
	close(f);
	//println("keys = ", keys_dict_str(&map));
	//println("vals = ", vals_dict_str(&map));  // hard to read, no quotes

	let node = "you";
	let dest = "out";
	let npaths = 0;
	search(&map, node, dest, &npaths);

	sum_ = npaths;

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let map = new_dict_str();

	let f = open(filename, "r");
	//f = open("test-input2.txt", "r");  // part 2 has different test input

	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);
		let chunks = split_(str_, ":");
		let node = chunks[0];
		let children = chunks[1];
		set_dict_str(&map, node, children);
		str_ = readln(f);
	}
	close(f);
	//println("keys = ", keys_dict_str(&map));
	//println("vals = ", vals_dict_str(&map));  // hard to read, no quotes

	//****************
	//
	// Divide the problem into several smaller ones. Ignoring intermediate
	// nodes, there are 2 ways to get from "svr" to "out" with the desired nodes
	// in between:
	//
	//         -> dac -> fft
	//        /n1     n2    \n3
	//     svr               -> out
	//        \na     nb    /nc
	//         -> fft -> dac
	//
	// While counting the ways to get *directly* from svr to dac, we want to
	// ignore fft.  That is what the `avoid` argument in count_paths() is for
	//
	// Then the total number of paths from svr to out is:
	//
	//      n1*n2*n3 + na*nb*nc
	//
	// Where n1 is the number of paths from svr to dac, etc.
	//
	//****************

	let cache = new_dict_i64();
	let nsvr2dac = count_paths(&map, &cache, "svr", "dac", "fft"); // avoid fft here
	//println("nsvr2dac = ", nsvr2dac);

	cache = new_dict_i64(); // cache invalidation is hard :(
	let nsvr2fft = count_paths(&map, &cache, "svr", "fft", "dac");
	//println("nsvr2fft = ", nsvr2fft);
	//****************

	cache = new_dict_i64();
	let ndac2fft = count_paths(&map, &cache, "dac", "fft", "");  // nothing to avoid here
	//println("ndac2fft = ", ndac2fft);

	cache = new_dict_i64();
	let nfft2dac = count_paths(&map, &cache, "fft", "dac", "");
	//println("nfft2dac = ", nfft2dac);

	//****************

	cache = new_dict_i64();
	let ndac2out = count_paths(&map, &cache, "dac", "out", "fft");
	//println("ndac2out = ", ndac2out);

	cache = new_dict_i64();
	let nfft2out = count_paths(&map, &cache, "fft", "out", "dac");
	//println("nfft2out = ", nfft2out);
	//****************

	sum_ =
		(nsvr2fft * nfft2dac * ndac2out) +
		(nsvr2dac * ndac2fft * nfft2out);

	println("part 2 = ", sum_);
	return str(sum_);
}

fn count_paths(map: &dict_str, cache: &dict_i64, node: str, dest: str, avoid: str): i64
{
	// Count the number of paths from `node` to `dest` without hitting the
	// `avoid` node.  The graph connectivity is defined in `map` and a `cache`
	// is used to help count efficiently without re-visiting sub-paths multiple
	// times

	let hit = get_dict_i64(&cache, node);
	if (hit >= 0) return hit;  // cache hit

	// Otherwise, cache miss

	// Base cases
	if node == avoid
	{
		set_dict_i64(&cache, node, 0'i64);
		return 0'i64;
	}
	if node == dest
	{
		set_dict_i64(&cache, node, 1'i64);
		return 1'i64;
	}

	// Recursive case -- sum up the children's path counts
	let npaths = 0'i64;
	let children = get_dict_str(&map, node);
	for child in split_(children, " ")
		npaths += count_paths(&map, &cache, child, dest, avoid);
	set_dict_i64(&cache, node, npaths);
	return npaths;
}

fn search(map: &dict_str, node: str, dest: str, npaths: &i32)
{
	// Brute force for part 1 without caching
	if node == dest
		npaths += 1;

	// DFS
	let children = get_dict_str(&map, node);
	for child in split_(children, " ")
		search(&map, child, dest, &npaths);
	return;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/11");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

