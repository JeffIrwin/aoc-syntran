
#include("../../utils.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		//println("words = ", words);

		let lits_str = words[0];
		//println("lits_str = ", lits_str);
		let nlits = len(lits_str) - 2;
		let lits_goal = vec_str(lits_str[1: nlits+1]) == "#";
		//println("lits_goal = ", lits_goal);

		let nbuts = size(words,0) - 2;
		//println("nbuts = ", nbuts);
		let buts = [false; nlits, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buts[parse_i32_delim(but_str, "(,)"), ib] = true;
		}
		//println("buts = ", buts);

		let npress = 0;
		let has_solution = false;
		while true
		{
			npress += 1;  // no input is ever all [......] reachable in 0 presses
			let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

			// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
			let n = nbuts;
			let k = npress;
			while true {
				for i in [k: -1: 0] {
					if (pos[i] > n - 1)
					{
						pos[i-1] += 1;
						for j in [i: k+1]
							pos[j] = pos[j-1];
					}
				}
				if (pos[0] > 0) break;
				//println("pos = ", pos);

				// Apply button presses according to `pos` combination
				let state = [false; nlits];
				for p in pos[1: npress+1]
					for i in [0: nlits]
						state[i] = state[i] != buts[i,p];
				//println("state = ", state);
				if all(state == lits_goal)
				{
					has_solution = true;
					break;
				}
				pos[k] += 1;
			}
			if (has_solution)
			{
				sum_ += npress;
				break;
			}
		}
		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn transpose_(a: [i32; :,:]): [i32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn transpose_f64(a: [f64; :,:]): [f64; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0.0'f64; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn matmul_vec_(mat: [f64; :,:], vec: [f64; :]): [f64; :]
{
	// Matrix-vector multiplication.  Return mat * vec
	let n = size(mat,0);
	let ans =  [0.0; n];
	for     j in [0: size(mat,1)]
		for i in [0: size(mat,0)]
			ans[i] = ans[i] + mat[i,j] * vec[j];
	return ans;
}

//fn ilp_solve(a: [i32; :,:], b: [i32; :]): [i32; :]
fn ilp_solve(a: [i32; :,:], b: [i32; :]): i32
{
	// This is a crude integer linear programming (ILP) solver
	//
	// First, Gaussian elimination is applied to the augmented matrix to make it
	// row-echelon form.  This reduces the dimension of the search space.
	//
	// Then the reduced search space is brute forced over all possible integer
	// values of free variables, while back-substituting to solve for the other
	// variables
	//
	// Searching could probably be improved with something like the "branch and
	// bound" algorithm
	//
	//**************************************************************************

	//println("a init = ", transpose_(a)); // transpose for sane display

	let m = i32(size(a,0));
	let n = i32(size(a,1));

	// Form augmented matrix tableau
	//let t = [0; m, n+1];
	//let t = [0.0'f64; m+1, n+2];
	let t = [0.0'f64; m, n+1];
	t[0:m, 0:n] = a;
	t[0:m, n] = b;
	//println("t = ", transpose_f64(t));

	// Gaussian elimination to (reduced?) row echelon form
	let idx = [-1; m];   // save index of first non-zero in row after reduction
	//let piv = [0: n];   // not used?
	let ifree = [0; n]; // list of free variables (over-allocated)
	let nfree = 0;
	let h = 0;
	let k = 0;
	while h < m and k < n
	{
		// Find pivot
		let imax = h;
		let amax = abs(t[h,k]);
		for i in [h+1: m]
			if abs(t[i,k]) > amax
			{
				amax = abs(t[i,k]);
				imax = i;
			}
		//println("imax, amax = ", imax, amax);

		//if t[imax,k] == 0.0'f64
		if abs(t[imax,k]) < 1.e-3
		{
			ifree[nfree] = k;
			nfree += 1;
			k += 1;
		}
		else
		{
			idx[h] = k;
			//println("swapping");

			//println("imax, h = ", [imax, h]);

			// Swap rows h and imax
			if imax != h
			{
				// TODO: guard is need because syntran debug can crash while
				// swapping row with itself.  Fix in interpretter
				t[[h, imax], :] = t[[imax, h], :];
				//piv[[h, imax]] = piv[[imax, h]];
			}

			//println("reducing");
			for i in [h+1: m]  // REF. this is probably fine, and more efficient
			{
				//if (i == h) continue;
				let f = t[i,k] / t[h,k];
				t[i,k] = 0.0'f64;
				for j in [k+1: n+1]
					t[i,j] -= t[h,j] * f;
			}
			h += 1;
			k += 1;
		}
	}
	//println("t ref = ", transpose_f64(t));
	//println("idx = ", idx);
	////println("piv = ", piv);

	// Get the rest of the free vars
	//println("m, n = ", [m, n]);
	for k in [m: n]
	{
		if (any(ifree == k)) continue;
		ifree[nfree] = k;
		nfree += 1;
	}
	if (nfree > 0) ifree = ifree[0: nfree]; // trim
	//println("nfree = ", nfree);
	//println("ifree = ", ifree);

	//let ixmax = sum(b); // better upper bound?
	let ixmax = maxval(b);
	//ixmax = minval(b);
	ixmax = (minval(b) + maxval(b)) / 2;
	//ixmax = minval(b) + (maxval(b) - minval(b)) / 4;  // too low
	//println("ixmax = ", ixmax);

	let nfixed = 0;
	let ifixed = [0; n];
	for k in [0: m]
	{
		if (any(k == ifree)) continue;
		if all(abs(t[k,0:n]) < 0.0001)
		{
			//ifree[nfree] = k;
			//nfree += 1;
			ifixed[nfixed] = k;
			nfixed += 1;
		}
	}
	//ifree = ifree[0: nfree]; // trim

	// Some of this paranoid 0-size checking may be unnecessary but i was
	// getting weird crashes before padding x size to n+1 below :(
	if (nfixed > 0) ifixed = ifixed[0: nfixed];
	//println("ifixed = ", ifixed);
	//println("nfixed = ", nfixed);

	let xopt = [0.0'f64; n];
	let fopt = 1.e20;

	// Iterate over possible value combinations of free vars
	//let combos = [0; ixmax+1];
	let combos = [0];
	if (nfree > 0) combos = [0; nfree];
	while true
	{
		let x = [0.0'f64; max(m,n)+1]; // n+1?? wtf!???!?!?!?!?

		if (nfree > 0) x[ifree] = combos;
		//println("combos = ", combos);
		//println("x[ifree] = ", x[ifree]);
		//println("ifixed = ", ifixed);

		//println("checking fixed");
		if (nfixed > 0)
		{
			x[ifixed] = 0.0;
		}
		//println("done checking fixed");

		// Back substitute to solve for the other vars
		for i in [m-1: -1: -1] // maybe this loop should start at n-1
		{
			if (nfixed > 0) if (any(idx[i] == ifixed)) continue;
			//if (any(idx[i] == ifree)) continue;
			if (idx[i] < 0) continue;
			//println("idx[i] = ", idx[i]);

			// TODO: helper var for idx[i]
			x[idx[i]] = t[i,n];
			for j in [idx[i]+1: n]
				x[idx[i]] -= t[i,j] * x[j];
			x[idx[i]] /= t[i, idx[i]];
		}
		//let diff = sum(abs(matmul_vec_(t[:, 0:n], x) - t[:,n]));
		//println("diff = ", diff);
		//println("x = ", x);
		////break;
		//if (diff > 0.0001)
		//{
		//	println("Error: bad linear algebra solve");
		//	exit(1);
		//}

		let eps = abs(x) % 1.0;
		if (all(x >= -0.001))
			//if (all(abs(x) % 1.0'f64 < 0.1)) // integer check (not working)
			//if (all(abs(x) % 1.0'f64 < 0.01)) // integer check
			if (all(eps < 0.0001 or eps > 0.9999)) // integer check
				if (sum(abs(x)) < fopt)
				{
					fopt = sum(abs(x));
					xopt = x;
				}
		if nfree == 0
			break;
		if not next_combo(&combos, ixmax)
			break;
		//next_combo(&combos, nfree, ixmax);
		//if combos[0] > 0
		//	break;
	}
	println("Optimal solution: ", xopt);
	println("sum(xopt) = ", sum(xopt));

	// Syntran needs nint!
	let isum = i32(sum(xopt));
	if isum < sum(xopt) - 0.5
		isum += 1;
	return isum;

	//let ix = i32(xopt);
	//println("ix = ", ix);
	//return ix;
	////return i32(xopt);
}

fn next_combo(c: &[i32; :], n: i32): bool
{
	// Bignum += 1 algo for number in array c with each digit/element base n
	if size(c,0) == 0
		return false;

	if all(c == n-1) // last possible combo
		return false;

	// Find first digit less than n-1
	let i = 0;
	while c[i] == n-1
	{
		c[i] = 0;
		i += 1;
	}
	c[i] += 1;
	return true;
}

fn next_combo_old(pos: &[i32; :], n: i32, k: i32)
{
	// TODO: one arg is redundant, related to size of pos
	//
	// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C

	//let pos = [0; npress+1]; // entry 0 is a dummy for the break condition
	//let n = nbuts;
	//let k = npress;
	//while true {
		pos[k] += 1;
		for i in [k: -1: 0] {
			if (pos[i] > n - 1)
			{
				pos[i-1] += 1;
				for j in [i: k+1]
					pos[j] = pos[j-1];
			}
		}
		//if (pos[0] > 0) break;
		//println("pos = ", pos);

		//// Apply button presses according to `pos` combination
		//let state = [false; nlits];
		//for p in pos[1: npress+1]
		//	for i in [0: nlits]
		//		state[i] = state[i] != buts[i,p];
		////println("state = ", state);
		//if all(state == lits_goal)
		//{
		//	has_solution = true;
		//	break;
		//}
		//pos[k] += 1;
	//}
	//if (has_solution)
	//{
	//	sum_ += npress;
	//	break;
	//}
	return;
}

fn part2(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	let iline = 0;
	while not eof(f)
	{
		iline += 1;
		let words = split_(str_, " ");

		let jlts_str = words[size(words,0)-1];
		let jlts_goal = parse_i32_delim(jlts_str, "{,}");
		let njlts = size(jlts_goal,0);

		let nbuts = size(words,0) - 2;
		let buts = [0; njlts, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			buts[parse_i32_delim(but_str, "(,)"), ib] = 1;
		}
		println("buts = ", buts);
		println("jlts_goal = ", jlts_goal);

		//let xl = ilp_solve(buts, jlts_goal);
		let isum = ilp_solve(buts, jlts_goal);
		//println("xl = ", xl);
		//exit(0);

		println("Line: ", iline);
		//println("Optimal solution: ", xl);
		//println("Optimal value: ", sum(xl));
		println("Optimal value: ", isum);
		println(" ");

		sum_ += isum;
		//break; // TODO

		println();
		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/10");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

