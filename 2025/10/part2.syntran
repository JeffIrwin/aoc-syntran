    // Run:  syntran part2.syntran
    //
    // Install syntran:  https://github.com/JeffIrwin/syntran#install-binary
    
    #include("../../utils.syntran");  // utils includes split_ and parse_i32_delim
    fn main(): str {
    	let sum_ = 0'i64;
    	let f = open("input.txt", "r");
    	let str_ = readln(f);
    	let iline = 0;
    	while not eof(f) {
    		iline += 1;
    		let words = split_(str_, " ");
    		let jolts_str = words[size(words,0)-1];
    		let jolts_goal = parse_i32_delim(jolts_str, "{,}");
    		let num_jolts = size(jolts_goal,0);
    		let num_buttons = size(words,0) - 2;
    		let buttons = [0; num_jolts, num_buttons];
    		for ib in [0: num_buttons] {  // assemble button matrix
    			let button_str = words[ib+1];
    			buttons[parse_i32_delim(button_str, "(,)"), ib] = 1;
    		}
    		let iopt = solve_ilp(buttons, jolts_goal);
    		sum_ += sum(iopt);
    		//println("Optimal solution: ", iopt);
    		//println("Optimal value: ", sum(iopt));
    		str_ = readln(f);
    	}
    	close(f);
    	println("part 2 = ", sum_);
    	return str(sum_);
    }
    return main();
    
    fn solve_ilp(a: [i32; :,:], b: [i32; :]): [i32; :] {
    	// Solve an integer linear programming problem:  minimize sum(x) for a*x == b with x >= 0 and integer x
    	let m = i32(size(a,0));
    	let n = i32(size(a,1));
    	let t = [0.0'f32; m, n+1];  // Form augmented matrix tableau
    	t[0:m, 0:n] = a;
    	t[0:m, n] = b;
    	let inonz = [-1; m];  // list of first (left-most) non-zero index in each row after reduction
    	let ifree = [0; n];   // list of free variables
    	let nfree = 0;
    	let h = 0;
    	let k = 0;
    	while h < m and k < n {  // Gaussian elimination to reduced row echelon form
    		let imax = h;
    		let amax = abs(t[h,k]);
    		for i in [h+1: m]  // Find pivot
    			if abs(t[i,k]) > amax {
    				amax = abs(t[i,k]);
    				imax = i;
    			}
    		if abs(t[imax,k]) < 0.0001'f32 {
    			ifree[nfree] = k;
    			nfree += 1;
    			k += 1;
    		} else {
    			inonz[h] = k;
    			if (h != imax) t[[h, imax], :] = t[[imax, h], :];  // swap rows h and imax
    			for i in [0: m] {  // RREF
    				if (i == h) continue;
    				let f = t[i,k] / t[h,k];
    				t[i,k] = 0.0'f32;
    				t[i, k+1: n+1] -= t[h, k+1: n+1] * f;
    			}
    			h += 1;
    			k += 1;
    		}
    	}
    	for k in [m: n] {  // Get the rest of the free variables
    		if (any(ifree == k)) continue;
    		if (any(inonz == k)) continue;
    		ifree[nfree] = k;
    		nfree += 1;
    	}
    	ifree = ifree[0: nfree];  // trim
    	let imaxes = [0; n];
    	for j in [0: n]
    		for i in [0: m]
    			if a[i,j] != 0
    				imaxes[j] = max(imaxes[j], b[i]);  // upper bound of search space
    	let xopt = [0.0'f32; n];
    	let fopt = 1.e20'f32;
    	imaxes = imaxes[ifree];
    	let combos = [0; nfree];
    	let i0 = -1;  // I guess you could also swap columns instead of using `inonz`
    	for i in [m-1: -1: -1]
    		if inonz[i] >= 0 {
    			i0 = i; // max non-free var
    			break;
    		}
    	let x = [0.0'f32; n];
    	while true {  // Iterate over possible value combinations of free variables
    		let sumx = sum(1.0'f32 * combos);  // initialize sum to free variables only
    		if sumx < fopt {  // fast non-optimal check
    			let is_valid = true;
    			x = 0.0'f32;
    			x[ifree] = combos;
    			for i in [i0: -1: -1] {  // Back substitute to solve for the other variables
    				let k = inonz[i];
    				x[k] = t[i,n];
    				x[k] -= dot(t[i, ifree], x[ifree]);  // RREF saves math here with a smaller sparse dot product
    				x[k] /= t[i,k];
    				is_valid = x[k] > -0.0001;
    				if (not is_valid) break;
    				sumx += x[k];
    				is_valid = sumx < fopt;
    				if (not is_valid) break;
    				is_valid = is_int(x[k]);
    				if (not is_valid) break;
    			}
    			if is_valid {
    				fopt = sumx;
    				xopt = x;
    			}
    		}
    		if (not next_combo(&combos, &imaxes)) break;
    	}
    	let iopt = i32(xopt);
    	for i in [0: n]
    		if iopt[i] < xopt[i] - 0.5'f32
    			iopt[i] += 1;  // round solution
    	return iopt;
    }
    fn is_int(x: f32): bool {
    	let frac_ = abs(x) % 1.0'f32;
    	if (frac_ < 0.0001'f32) return true;
    	if (frac_ > 0.9999'f32) return true;
    	return false;
    }
    fn next_combo(c: &[i32; :], n: &[i32; :]): bool {
    	// Bignum += 1 algo for number in array c with mixed radix
    	let nc = size(c,0);
    	if (nc == 0) return false;
    	let i = 0;  // Find first digit less than n-1
    	while c[i] == n[i]-1 {
    		c[i] = 0;
    		i += 1;
    		if (i == nc) return false;
    	}
    	c[i] += 1;
    	return true;
    }
