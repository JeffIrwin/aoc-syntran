
#include("../../utils.syntran");

// I had to cheat for part 2 here by looking at the reddit *and* I still just
// ended up shelling out to scipy
//
// Part 2 is an integer programming problem
//
// I recently ported scipy's simplex algorithm to Fortran:
//
//     https://github.com/JeffIrwin/numerical-analysis/blob/7067e5fe7d331f817c5c9f9cf922b44af7a18aa9/src/linprog.F90
//
// That was a grueling experience, and *integer* programming is even more
// complicated than just *linear* programming.  I'm not looking to repeat it
//
// My approach here is that syntran generates the python code to solve the
// problem, just as an excuse to keep syntran in the loop. Syntran is really
// only parsing the input for part 2 and scipy does everything else
//
// There is a scipy int programming example here:
//
//     https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.milp.html
//
// In this directory, `test.py` basically follows the scipy doc's example, but
// modified to solve the first line of AOC's sample/test input. From there, it
// is easy to iterate over all the inputs and generate similar python code for
// each input line, and sum it all up
//
// Run part 2 like this:
//
//     syntran main.syntran && python3 script.py

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		//println("words = ", words);

		let lits_str = words[0];
		//println("lits_str = ", lits_str);
		let nlits = len(lits_str) - 2;
		let lits_goal = vec_str(lits_str[1: nlits+1]) == "#";
		//println("lits_goal = ", lits_goal);

		let nbuts = size(words,0) - 2;
		//println("nbuts = ", nbuts);
		let buts = [false; nlits, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buts[parse_i32_delim(but_str, "(,)"), ib] = true;
		}
		//println("buts = ", buts);

		let npress = 0;
		let has_solution = false;
		while true
		{
			npress += 1;  // no input is ever all [......] reachable in 0 presses
			let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

			// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
			let n = nbuts;
			let k = npress;
			while true {
				for i in [k: -1: 0] {
					if (pos[i] > n - 1)
					{
						pos[i-1] += 1;
						for j in [i: k+1]
							pos[j] = pos[j-1];
					}
				}
				if (pos[0] > 0) break;
				//println("pos = ", pos);

				// Apply button presses according to `pos` combination
				let state = [false; nlits];
				for p in pos[1: npress+1]
					for i in [0: nlits]
						state[i] = state[i] != buts[i,p];
				//println("state = ", state);
				if all(state == lits_goal)
				{
					has_solution = true;
					break;
				}
				pos[k] += 1;
			}
			if (has_solution)
			{
				sum_ += npress;
				break;
			}
		}
		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let fo = open("script.py", "w"); // open generated python script

	writeln(fo, "# This script was generated by AOC 2025 day 10 main.syntran");
	writeln(fo, "import numpy as np");
	writeln(fo, "from scipy.optimize import milp, LinearConstraint, Bounds");
	writeln(fo, "sum_ = 0");

	let f = open(filename, "r");
	let str_ = readln(f);
	let iline = 0;
	while not eof(f)
	{
		iline += 1;
		let words = split_(str_, " ");

		let jlts_str = words[size(words,0)-1];
		let jlts_goal = parse_i32_delim(jlts_str, "{,}");
		let njlts = size(jlts_goal,0);

		let nbuts = size(words,0) - 2;
		let buts = [0; njlts, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			buts[parse_i32_delim(but_str, "(,)"), ib] = 1;
		}

		// Objective function coefficients
		writeln(fo, "c = np.array(" + str([1; nbuts]) + ")");

		// Constraint matrix and bounds
		writeln(fo, "A = np.array([");
		for i in [0: njlts]
			writeln(fo, "    " + str(buts[i,:]) + ",");
		writeln(fo, "])");

		writeln(fo, "b_l = " + str(jlts_goal));  // lower bounds
		writeln(fo, "b_u = " + str(jlts_goal));  // upper bounds

		// Variable bounds
		writeln(fo, "bounds = Bounds(");
		writeln(fo, str([0; nbuts]) + ",");
		writeln(fo, "[" + repeat("np.inf, ", i32(nbuts)) + "]");
		writeln(fo, ")");

		// Integrality constraints (all variables are integers)
		writeln(fo, "integrality = " + str([1; nbuts]));

		// Linear constraints
		writeln(fo, "constraints = LinearConstraint(A, b_l, b_u)");

		// Solve MILP
		writeln(fo, "result = milp(c=c, integrality=integrality, bounds=bounds, constraints=constraints)");

		//// Display results
		//writeln(fo, "print(""Optimal Solution:"", result.x)");
		//writeln(fo, "print(""Optimal Value:"", result.fun)");

		// Add up final AOC answer
		writeln(fo, "sum_ += result.fun");

		str_ = readln(f);
	}
	//writeln(fo, "print(""sum = "", sum_)");
	writeln(fo, "print(""part 2 = "", int(sum_))");
	close(f);
	close(fo);

	println("part 2 = `python3 script.py`");
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/10");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

