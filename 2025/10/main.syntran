
#include("../../utils.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		//println("words = ", words);

		let lits_str = words[0];
		//println("lits_str = ", lits_str);
		let nlits = len(lits_str) - 2;
		let lits_goal = vec_str(lits_str[1: nlits+1]) == "#";
		//println("lits_goal = ", lits_goal);

		let num_buttons = size(words,0) - 2;
		//println("num_buttons = ", num_buttons);
		let buttons = [false; nlits, num_buttons];
		for ib in [0: num_buttons]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buttons[parse_i32_delim(but_str, "(,)"), ib] = true;
		}
		//println("buttons = ", buttons);

		let npress = 0;
		let has_solution = false;
		while true
		{
			npress += 1;  // no input is ever all [......] reachable in 0 presses
			let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

			// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
			let n = num_buttons;
			let k = npress;
			while true {
				for i in [k: -1: 0] {
					if (pos[i] > n - 1)
					{
						pos[i-1] += 1;
						for j in [i: k+1]
							pos[j] = pos[j-1];
					}
				}
				if (pos[0] > 0) break;
				//println("pos = ", pos);

				// Apply button presses according to `pos` combination
				let state = [false; nlits];
				for p in pos[1: npress+1]
					for i in [0: nlits]
						state[i] = state[i] != buttons[i,p];
				//println("state = ", state);
				if all(state == lits_goal)
				{
					has_solution = true;
					break;
				}
				pos[k] += 1;
			}
			if (has_solution)
			{
				sum_ += npress;
				break;
			}
		}
		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn transpose_(a: [i32; :,:]): [i32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn transpose_f32(a: [f32; :,:]): [f32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0.0'f32; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn solve_ilp(a: [i32; :,:], b: [i32; :]): [i32; :]
{
	// This is a crude integer linear programming (ILP) solver
	//
	// First, Gaussian elimination is applied to the augmented matrix to make it
	// row-echelon form.  This reduces the dimension of the search space.
	//
	// Then the reduced search space is brute forced over all possible integer
	// values of free variables, while back-substituting to solve for the other
	// variables
	//
	// Searching could probably be improved with something like the "branch and
	// bound" algorithm
	//
	//**************************************************************************

	//println("a init = ", transpose_(a)); // transpose for sane display
	let m = i32(size(a,0));
	let n = i32(size(a,1));

	// Form augmented matrix tableau
	let t = [0.0'f32; m, n+1];
	t[0:m, 0:n] = a;
	t[0:m, n] = b;

	// Gaussian elimination to (reduced?) row echelon form
	let inonz = [-1; m];  // list of first (left-most) non-zero index in each row after reduction
	let ifree = [0; n];   // list of free variables
	let nfree = 0;
	let h = 0;
	let k = 0;
	while h < m and k < n
	{
		// Find pivot
		let imax = h;
		let amax = abs(t[h,k]);
		for i in [h+1: m]
			if abs(t[i,k]) > amax
			{
				amax = abs(t[i,k]);
				imax = i;
			}
		println("imax, amax = ", imax, amax);

		if abs(t[imax,k]) < 0.0001'f32
		{
			//println("skipped piv k = ", k);
			ifree[nfree] = k;
			nfree += 1;
			k += 1;
		}
		else
		{
			//println("swapping");
			println("imax, h = ", [imax, h]);
			inonz[h] = k;
			if (h != imax) t[[h, imax], :] = t[[imax, h], :];  // swap rows h and imax. TODO: fix interpretter

			for i in [0: m]  // RREF
			{
				if (i == h) continue;
				let f = t[i,k] / t[h,k];
				t[i,k] = 0.0'f32;
				t[i, k+1: n+1] -= t[h, k+1: n+1] * f;
			}
			h += 1;
			k += 1;
		}
	}
	println("t ref = ", transpose_f32(t));
	println("inonz = ", inonz);

	// Get the rest of the free vars
	for k in [m: n]
	{
		if (any(ifree == k)) continue;
		if (any(inonz == k)) continue;
		ifree[nfree] = k;
		nfree += 1;
	}
	ifree = ifree[0: nfree];  // trim
	println("nfree = ", nfree);
	println("ifree = ", ifree);

	let imaxes = [0; n];
	for j in [0: n]
	for i in [0: m]
		if a[i,j] != 0
			imaxes[j] = max(imaxes[j], b[i]);  // upper bound of search space
	//println("imaxes (full) = ", imaxes);
	//println("m, n, max inonz = ", [m, n, maxval(inonz)]);

	let xopt = [0.0'f32; n];
	let fopt = 1.e20'f32;

	// Iterate over possible value combinations of free vars
	imaxes = imaxes[ifree];  // TODO: interpretter breaks on some empty ifree array like this in debug
	let combos = [0; nfree];
	println("imaxes = ", imaxes);

	//// This hack was useful for development, but it only saves 1 minute (2 vs 3)
	//// now with other optimizations
	//for i in [0: size(imaxes,0)]
	//	imaxes[i] = min(imaxes[i], 210);

	// I guess you could also swap columns instead of using `inonz`
	let i0 = -1;
	for i in [m-1: -1: -1]
		if inonz[i] >= 0
		{
			i0 = i; // max non-free var
			break;
		}

	let x = [0.0'f32; n];
	println("imaxes = ", imaxes, " (perms = ", product(imaxes), ")");
	while true
	{
		let sumx = sum(1.0'f32 * combos);  // initialize sum to free vars only
		if sumx < fopt  // fast non-optimal check
		{
			let is_valid = true;
			x = 0.0'f32;
			x[ifree] = combos;
			//println("combos = ", combos);
			//println("x[ifree] = ", x[ifree]);

			// Back substitute to solve for the other vars
			for i in [i0: -1: -1]
			{
				let k = inonz[i];
				x[k] = t[i,n];
				x[k] -= dot(t[i, ifree], x[ifree]);  // rref saves math here, shorter sparse dot prod dims
				x[k] /= t[i,k];

				is_valid = x[k] > -0.0001;
				if (not is_valid) break;

				sumx += x[k];
				is_valid = sumx < fopt;
				if (not is_valid) break;

				is_valid = is_int(x[k]);
				if (not is_valid) break;
			}
			if is_valid
			{
				fopt = sumx;
				println("fopt = ", fopt);
				xopt = x;
			}
		}
		if (not next_combo(&combos, &imaxes)) break;
	}
	println("Optimal solution: ", xopt);
	println("sum(xopt) = ", sum(xopt));

	let iopt = i32(xopt);
	for i in [0: n]
		if iopt[i] < xopt[i] - 0.5'f32
			iopt[i] += 1;  // round
	return iopt;
}

fn is_int(x: f32): bool
{
	let frac_ = abs(x) % 1.0'f32;
	if (frac_ < 0.0001'f32) return true;
	if (frac_ > 0.9999'f32) return true;
	return false;
}

fn next_combo(c: &[i32; :], n: &[i32; :]): bool
{
	// Bignum += 1 algo for number in array c with mixed radix
	let nc = size(c,0);
	if (nc == 0) return false;

	// Find first digit less than n-1
	let i = 0;
	while c[i] == n[i]-1
	{
		c[i] = 0;
		i += 1;
		if (i == nc) return false;
	}
	c[i] += 1;
	return true;
}

fn part2(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	let iline = 0;
	while not eof(f)
	{
		iline += 1;
		let words = split_(str_, " ");

		let jolts_str = words[size(words,0)-1];
		let jolts_goal = parse_i32_delim(jolts_str, "{,}");
		let num_jolts = size(jolts_goal,0);

		let num_buttons = size(words,0) - 2;
		let buttons = [0; num_jolts, num_buttons];
		for ib in [0: num_buttons]  // assemble button matrix
		{
			let but_str = words[ib+1];
			buttons[parse_i32_delim(but_str, "(,)"), ib] = 1;
		}
		println("buttons = ", buttons);
		println("jolts_goal = ", jolts_goal);

		let iopt = solve_ilp(buttons, jolts_goal);
		sum_ += sum(iopt);

		println("Line: ", iline);
		println("Optimal solution: ", iopt);
		println("Optimal value: ", sum(iopt));
		println(" ");

		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/10");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

