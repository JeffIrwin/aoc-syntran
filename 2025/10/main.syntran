
#include("../../utils.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		//println("words = ", words);

		let lits_str = words[0];
		//println("lits_str = ", lits_str);
		let nlits = len(lits_str) - 2;
		let lits_goal = vec_str(lits_str[1: nlits+1]) == "#";
		//println("lits_goal = ", lits_goal);

		let nbuts = size(words,0) - 2;
		//println("nbuts = ", nbuts);
		let buts = [false; nlits, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buts[parse_i32_delim(but_str, "(,)"), ib] = true;
		}
		//println("buts = ", buts);

		let npress = 0;
		let has_solution = false;
		while true
		{
			npress += 1;  // no input is ever all [......] reachable in 0 presses
			let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

			// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
			let n = nbuts;
			let k = npress;
			while true {
				for i in [k: -1: 0] {
					if (pos[i] > n - 1)
					{
						pos[i-1] += 1;
						for j in [i: k+1]
							pos[j] = pos[j-1];
					}
				}
				if (pos[0] > 0) break;
				//println("pos = ", pos);

				// Apply button presses according to `pos` combination
				let state = [false; nlits];
				for p in pos[1: npress+1]
					for i in [0: nlits]
						state[i] = state[i] != buts[i,p];
				//println("state = ", state);
				if all(state == lits_goal)
				{
					has_solution = true;
					break;
				}
				pos[k] += 1;
			}
			if (has_solution)
			{
				sum_ += npress;
				break;
			}
		}
		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn transpose_(a: [i32; :,:]): [i32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn transpose_f32(a: [f32; :,:]): [f32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0.0'f32; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn ilp_solve(a: [i32; :,:], b: [i32; :]): i32
{
	// This is a crude integer linear programming (ILP) solver
	//
	// First, Gaussian elimination is applied to the augmented matrix to make it
	// row-echelon form.  This reduces the dimension of the search space.
	//
	// Then the reduced search space is brute forced over all possible integer
	// values of free variables, while back-substituting to solve for the other
	// variables
	//
	// Searching could probably be improved with something like the "branch and
	// bound" algorithm
	//
	//**************************************************************************

	//println("a init = ", transpose_(a)); // transpose for sane display
	let m = i32(size(a,0));
	let n = i32(size(a,1));

	// Form augmented matrix tableau
	let t = [0.0'f32; m, n+1];
	t[0:m, 0:n] = a;
	t[0:m, n] = b;

	// Gaussian elimination to (reduced?) row echelon form
	let inonz = [-1; m];  // list of first (left-most) non-zero in each row after reduction
	let ifree = [0; n];   // list of free variables
	let nfree = 0;
	let h = 0;
	let k = 0;
	while h < m and k < n
	{
		// Find pivot
		let imax = h;
		let amax = abs(t[h,k]);
		for i in [h+1: m]
			if abs(t[i,k]) > amax
			{
				amax = abs(t[i,k]);
				imax = i;
			}
		//println("imax, amax = ", imax, amax);

		if abs(t[imax,k]) < 0.0001'f32
		{
			//println("skipped piv k = ", k);
			ifree[nfree] = k;
			nfree += 1;
			k += 1;
		}
		else
		{
			inonz[h] = k;
			//println("swapping");
			//println("imax, h = ", [imax, h]);

			t[[h, imax], :] = t[[imax, h], :];  // swap rows h and imax

			for i in [0: m]  // RREF
			{
				if (i == h) continue;
				let f = t[i,k] / t[h,k];
				t[i,k] = 0.0'f32;
				t[i, k+1: n+1] -= t[h, k+1: n+1] * f;
			}
			h += 1;
			k += 1;
		}
	}
	//println("t ref = ", transpose_f32(t));
	println("inonz = ", inonz);

	// Get the rest of the free vars
	for k in [m: n]
	//for k in [m: n-1]
	//for k in [m+1: n]
	{
		if (any(ifree == k)) continue; // also important
		if (any(inonz == k)) continue;   // this one matters, otherwise i was getting extra free vars that got right ans but took too long
		ifree[nfree] = k;
		nfree += 1;
	}

	// Some of this paranoid 0-size checking may be unnecessary but i was
	// getting weird crashes before padding x size to n+1 below :(
	ifree = ifree[0: nfree]; // trim
	println("nfree = ", nfree);
	println("ifree = ", ifree);

	let imaxes = [0; n];
	for j in [0: n]
	for i in [0: m]
	{
		if a[i,j] != 0
			imaxes[j] = max(imaxes[j], b[i]);
	}
	//println("imaxes (full) = ", imaxes);
	//println("m, n, max inonz = ", [m, n, maxval(inonz)]);

	let xopt = [0.0'f32; n];
	let fopt = 1.e20'f32;

	// Iterate over possible value combinations of free vars
	let combos = [0];
	if (nfree > 0)
	{
		imaxes = imaxes[ifree];
		combos = [0; nfree];
	}
	println("imaxes = ", imaxes);

	for i in [0: size(imaxes,0)]
		imaxes[i] = min(imaxes[i], 210); // TODO: can this hack be removed for robustness?

	// I guess you could also swap columns instead of using `inonz`
	let i0 = -1;
	for i in [m-1: -1: -1]
		if inonz[i] >= 0
		{
			i0 = i; // max non-free var
			break;
		}

	let x = [0.0'f32; max(m,n)+1]; // TODO wtf??
	println("imaxes = ", imaxes, " (perms = ", product(imaxes), ")");
	while true
	{
		let sumx = sum(combos); // initialize sum to free vars only
		if sumx < fopt  // fast non-optimal check
		{
			let is_valid = true;
			x = 0.0'f32;
			x[ifree] = combos;
			//println("combos = ", combos);
			//println("x[ifree] = ", x[ifree]);

			// Back substitute to solve for the other vars
			for i in [i0: -1: -1]
			{
				let k = inonz[i];
				x[k] = t[i,n];
				x[k] -= dot(t[i, ifree], x[ifree]); // rref saves math here, shorter sparse dot prod dims
				x[k] /= t[i, k];

				is_valid = x[k] > -0.0001;
				if (not is_valid) break;

				sumx += x[k];
				is_valid = sumx < fopt;
				if (not is_valid) break;

				is_valid = is_int(x[k]);
				if (not is_valid) break;
			}

			// TODO: remove conditions here if we check everything above
			let frac_ = abs(x) % 1.0;
			if (all(x > -0.0001))
			{
				if (sum(abs(x)) < fopt)
				{
					if (all(frac_ < 0.0001 or frac_ > 0.9999)) // integer check
					{
						fopt = sum(abs(x));
						println("fopt = ", fopt);
						xopt = x;
					}
				}
			}
		}
		if nfree == 0
			break;
		if not next_combo(&combos, &imaxes)
			break;
	}
	println("Optimal solution: ", xopt);
	println("sum(xopt) = ", sum(xopt));

	// TODO: return int vec, careful with rounding. Make helper fn

	// Syntran needs nint!
	let isum = i32(sum(xopt));
	if isum < sum(xopt) - 0.5
		isum += 1;
	return isum;
}

fn is_int(x: f32): bool
{
	let frac_ = abs(x) % 1.0'f32;
	if (frac_ < 0.0001'f32) return true;
	if (frac_ > 0.9999'f32) return true;
	return false;
}
//let frac_ = abs(x) % 1.0;
//if (all(x > -0.0001))
//{
//	if (sum(abs(x)) < fopt)
//	{
//		if (all(frac_ < 0.0001 or frac_ > 0.9999)) // integer check
//		{
//			fopt = sum(abs(x));
//			println("fopt = ", fopt);
//			xopt = x;
//		}
//	}
//}

fn next_combo(c: &[i32; :], n: &[i32; :]): bool
{
	// Bignum += 1 algo for number in array c with mixed radix
	if size(c,0) == 0
		return false;

	if all(c == n-1) // last possible combo
		return false;

	// Find first digit less than n-1
	let i = 0;
	while c[i] == n[i]-1
	{
		c[i] = 0;
		i += 1;
	}
	c[i] += 1;
	return true;
}

fn part2(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	let iline = 0;
	while not eof(f)
	{
		iline += 1;
		let words = split_(str_, " ");

		// TODO: rename vars before reddit
		let jlts_str = words[size(words,0)-1];
		let jlts_goal = parse_i32_delim(jlts_str, "{,}");
		let njlts = size(jlts_goal,0);

		let nbuts = size(words,0) - 2;
		let buts = [0; njlts, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			buts[parse_i32_delim(but_str, "(,)"), ib] = 1;
		}
		//println("buts = ", buts);
		println("jlts_goal = ", jlts_goal);

		let isum = ilp_solve(buts, jlts_goal);
		//exit(0);

		println("Line: ", iline);
		println("Optimal value: ", isum);
		println(" ");

		sum_ += isum;
		//break;

		println();
		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/10");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

