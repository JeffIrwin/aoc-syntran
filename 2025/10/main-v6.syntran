
#include("../../utils.syntran");
#include("../../dict_i64.syntran");
#include("../../minheap_vec_i32.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		//println("words = ", words);

		let lits_str = words[0];
		//println("lits_str = ", lits_str);
		let nlits = len(lits_str) - 2;
		let lits_goal = vec_str(lits_str[1: nlits+1]) == "#";
		//println("lits_goal = ", lits_goal);

		let nbuts = size(words,0) - 2;
		//println("nbuts = ", nbuts);
		let buts = [false; nlits, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buts[parse_i32_delim(but_str, "(,)"), ib] = true;
		}
		//println("buts = ", buts);

		let npress = 0;
		let has_solution = false;
		while true
		{
			npress += 1;  // no input is ever all [......] reachable in 0 presses

			//let pos = [0; nbuts];
			//let pos = [0; npress];
			let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

			//void combination_with_repetiton(int n, int k) {
			//  while (1) {
			//    for (int i = k; i > 0; i -= 1) {
			//      if (pos[i] > n - 1) // if number spilled over: xx0(n-1)xx
			//      {
			//        pos[i - 1] += 1; // set xx1(n-1)xx
			//        for (int j = i; j <= k; j += 1)
			//          pos[j] = pos[j - 1]; // set xx11..1
			//      }
			//    }
			//    if (pos[0] > 0) // stop condition: 1xxxx
			//      break;
			//    printDonuts(k);
			//    pos[k] += 1; // xxxxN -> xxxxN+1
			//  }
			//}

			// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
			let n = nbuts;
			let k = npress;
			while true {
				for i in [k: -1: 0] {
					if (pos[i] > n - 1)
					{
						pos[i-1] += 1;
						for j in [i: k+1]
							pos[j] = pos[j-1];
					}
				}
				if pos[0] > 0
					break;

				//println("pos = ", pos);

				// Apply button presses according to `pos` combination
				let state = [false; nlits];
				for p in pos[1: npress+1]
				{
					//state ^= buts[:,p];
					for i in [0: nlits]
						state[i] = state[i] != buts[i,p];
				}
				//println("state = ", state);
				if all(state == lits_goal)
				{
					//println("**********************");
					//println("found solution");
					//println();
					has_solution = true;
					break;
				}

				pos[k] += 1;
			}

			if (has_solution)
			{
				sum_ += npress;
				break;
			}
			//if (npress == 3) break; // TODO

			// Example: 3 buttons with 1 total press
			//     [1, 0, 0]
			//     [0, 1, 0]
			//     [0, 0, 1]
			//
			// Example: 3 buttons with 2 total presses
			//     [2, 0, 0]
			//     [1, 1, 0]
			//     [1, 0, 1]
			//     [0, 2, 0]
			//     [0, 1, 1]
			//     [0, 0, 2]
			//
			// Example: 3 buttons with 3 total presses
			//     [3, 0, 0]
			//     [2, 1, 0]
			//     [2, 0, 1]
			//     [1, 2, 0]
			//     [1, 1, 1]
			//     [1, 0, 2]
			//     [0, 3, 0]
			//     [0, 2, 1]
			//     [0, 1, 2]
			//     [0, 0, 3]
		}
		//println();
		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn lu_invmul(a: [f64; :,:], b: [f64; :]): [f64; :]
{
	// Solve linear algebra problem a*x == b for x using LU decomposition

//	n = size(a, 1)
	let m = size(a,0);
	let n = size(a,1);
	let mn = min(m, n);
	let mx = max(m, n);

//	if (size(a, 2) /= n) then
//		msg = "matrix is not square in lu_factor_f64()"
//		call PANIC(msg, present(iostat))
//		iostat = 1
//		return
//	end if

//	if (.not. allocated(ipiv)) then
//		! Or we could just allocate and initialize (to identity perm) here
//		!
//		! Maybe this shouldn't be checked manually at all and we should just let
//		! a stacktrace get issued, as with `a`
//		msg = "ipiv is not allocated in lu_factor_f64()"
//		call PANIC(msg, present(iostat))
//		iostat = 2
//		return
//	end if
//	!print *, "ipiv init = ", ipiv

	let ipiv = [0: mn];
	//let ipiv = [0: n];
	//let ipiv = [0: m];
	println("ipiv = ", ipiv);
	println("m, n, mn, mx = ", [m, n, mn, mx]);

	let jpiv = [0: mn];

//	do i = 1, n
	//for i in [0: m]
	//for i in [0: n]
	for i in [0: mn]
	{
		// Find max value in column i
		println("a col i = ", a[:,i]);
		let max_index = i;
		let max_j     = i;
		let ip = ipiv[i];
		let amax = abs(a[ip,jpiv[i]]);
		for j in [i: m]
		//for j in [i+1: n]
		{
			let jp = ipiv[j];
			//if abs(a[jp,i]) > amax
			//{
			//	max_index = j;
			//	amax = abs(a[jp,i]);
			//}
			for k in [i: n]
			{
				let kp = jpiv[k];
				if abs(a[jp,kp]) > amax
				{
					max_index = j;
					max_j = k;
					amax = abs(a[jp,kp]);
				}
			}
		}
		println("amax = ", amax);
//		max_index = i
//		ip = ipiv(i)
//		amax = abs(a(ip, i))
//		!if (DO_PIVOT) then
//			do j = i+1, n
//				jp = ipiv(j)
//				!print *, "aj, ai = ", a(j,i), a(i,i)
//				if (abs(a(jp, i)) > amax) then
//					max_index = j
//					amax = abs(a(jp, i))
//				end if
//			end do
//		!end if

		// Swap rows
////		ipiv([i, max_index]) = ipiv([max_index, i])
////		ip = ipiv(i)
//		ipiv[[i, max_index]] = ipiv[[max_index, i]];
//		jpiv[[i, max_j    ]] = jpiv[[max_j    , i]];
//		ip = ipiv[i];

		a[[i, max_index], :] = a[[max_index, i], :];
		a[:, [i, max_j]] = a[:, [max_j, i]];
		println("    ipiv = ", ipiv);

//		!print *, "swapping ", i, max_index
//		!print *, "i = ", i
//		!call print_mat(a, "a unpiv = ")
//		!call print_mat(a(ipiv,:), "a ipiv = ")
//		!print *, "ap = ", a(ip, i)
//		!print *, "ai = ", a(i, i)
//		!print *, "ipiv = ", ipiv
//		!print *, ""

//		if (.not. allow_singular_ .and. a(ip, i) == 0) then
//			msg = "matrix is singular in lu_factor_f64()"
//			call PANIC(msg, present(iostat))
//			iostat = 3
//			return
//		end if
		if a[i, i] == 0.0
		{
			println("Error: matrix is singular in lu_invmul()");
			exit(1);
		}

//		do j = i+1, n
//			jp = ipiv(j)
//			a(jp, i) = a(jp, i) / a(ip, i)
//			do k = i+1, n
//				a(jp, k) = a(jp, k) - a(jp, i) * a(ip, k)
//			end do
//		end do

		for j in [i+1: m]
		//for j in [i+1: n]
		{
			// TODO: m or n for both of these loop bounds?
			let jp = j;//ipiv[j];
			a[jp, i] = a[jp, i] / a[i, i];
			for k in [i+1: n]
				a[jp, k] = a[jp, k] - a[jp, i] * a[i, k];
		}
//	end do
	}
	println("a (factored) = ", a);
	println("a (factored) = ", i32(a));

	// Factoring done

	// ****************************
	// Solve phase

//	n = size(a, 1)
//	!print *, "bx init = ", bx

//	! Forward substitution
//	do i = 1, n
//		ip = ipiv(i)
//		do j = 1, i-1
//			jp = ipiv(j)
//			bx(ip) = bx(ip) - a(ip, j) * bx(jp)
//		end do
//	end do
//	!print *, "bx forward = ", bx
	let x = b;
	for i in [0: mn]
	//for i in [0: m]
	//for i in [0: n]
	{
		// TODO: loop bounds?
		let ip = i;//ipiv[i];
		for j in [0: i]
		{
			let jp = j;//ipiv[j];
			x[ip] = x[ip] - a[ip, j] * x[jp];
		}
	}
	println("x forward = ", x);

//	call backsub(a, bx, ipiv)
//	n = min(size(a,1), size(a,2))

	for i in [m-1: -1: -1]
	//for i in [n-1: -1: -1]
	{
		let ip = i;//ipiv[i];
		for j in [i+1: n]
		{
			let jp = j;//ipiv[j];
			x[ip] = x[ip] - a[ip, j] * x[jp];
		}
		x[ip] = x[ip] / a[ip, i];
	}
	println("x backsub = ", x);

//	if (present(ipiv)) then
//		do i = n, 1, -1
//			ip = ipiv(i)
//			do j = i+1, n
//				jp = ipiv(j)
//				bx(ip) = bx(ip) - a(ip, j) * bx(jp)
//			end do
//			bx(ip) = bx(ip) / a(ip, i)
//		end do
//	else
//		do i = n, 1, -1
//			do j = i+1, n
//				bx(i) = bx(i) - a(i, j) * bx(j)
//			end do
//			bx(i) = bx(i) / a(i, i)
//		end do
//	end if
//	!print *, "bx back = ", bx

//	! Unipiv
//	bx = bx(ipiv)
//	!print *, "bx unipiv = ", bx
	//x = x[ipiv];
	println("x unipiv = ", x);

	return x;
	//return [0.0]; // TODO
}

fn part2(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	let iline = 0;
	while not eof(f)
	{
		println("iline = ", iline);
		iline += 1;
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		println("words = ", words);

		let jlts_str = words[size(words,0)-1];
		println("jlts_str = ", jlts_str);
		let jlts_goal = parse_i32_delim(jlts_str, "{,}");
		println("jlts_goal = ", jlts_goal);
		let njlts = size(jlts_goal,0);
		//exit(0);

		let nbuts = size(words,0) - 2;
		//println("nbuts = ", nbuts);
		let buts = [0; njlts, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buts[parse_i32_delim(but_str, "(,)"), ib] = 1;
		}
		println("buts = ", buts);

		let a = [0.0'f64; njlts, nbuts];
		a += buts;
		let b = [0.0'f64; njlts];
		b += jlts_goal;

		//let x = lu_invmul(f64(buts), f64(jlts_goal));
		let x = lu_invmul(a, b);

		println("x = ", x);
		//println("sum x = ", i32(sum(x)));
		println("sum x = ", i32(sum(x[0: nbuts])));
		exit(0);

		let DIST_INFTY = 2_000_000_000;

		// Dijkstra's algorithm with a minheap priority queue
		let dist = new_dict_i64();
		let seen = new_dict_i64();

		// Initialize source vertex to 0 distance and depth
		let src = [0; njlts];
		//let src = y;
		let src_str = str(src);
		set_dict_i64(&dist, src_str, 0'i64);
		let q = new_minheap_vec_i32();
		//let npre = 0;
		//push_minheap_vec_i32(&q, [[0, npre], src]);  // queue contains distance, depth, then coords

		// Try "preprocessing" before Dijkstra by just taking ~some trivial
		// steps in the right direction before starting Dijkstra search
		let npre = 0;
		let d2_goal = DIST_INFTY;
		let d2_thresh = 5 ** 2; // TODO
		let y = [0; njlts]; // current position
		let yg = jlts_goal - y;
		while d2_goal > d2_thresh
		{
			npre += 1;
			//println("y = ", y);

			// Do dot products to figure out which button takes us closest
			// towards the goal from our current position
			let dotmax = 0;
			let imax = -1;
			for i in [0: nbuts]
			{
				let dot_ = sum(yg * buts[:,i]);
				if dot_ > dotmax
				{
					dotmax = dot_;
					imax = i;
				}
			}
			if (imax < 0) break;
			y += buts[:,imax];
			yg = jlts_goal - y;
			d2_goal = sum(yg * yg);

			let ystr = str(y);
			set_dict_i64(&dist, ystr, i64(d2_goal));
			push_minheap_vec_i32(&q, [[d2_goal, npre], y]);
			//let src_str = str(src);
			//set_dict_i64(&dist, src_str, 0'i64);
			//let q = new_minheap_vec_i32();
			//let npre = 0;
			//push_minheap_vec_i32(&q, [[0, npre], src]);  // queue contains distance, depth, then coords
		}

		let dist_end = DIST_INFTY;
		while q.len > 0
		{
			let u = pop_minheap_vec_i32(&q);
			//println("u = ", u);

			// Unpack from vector
			let dist0  = u[0];
			let depth0 = u[1];
			let x0 = u[2: njlts+2];
			//println("x0 = ", x0);

			if all(x0 == jlts_goal)
			{
				//dist_end = min(dist_end, dist0);
				dist_end = min(dist_end, depth0);
				break;
			}

			//let x0str = str(x0);
			let x0str = str(u);
			let is_seen = get_dict_i64(&seen, x0str) == 1;
			if (is_seen) continue;
			set_dict_i64(&seen, x0str, 1'i64);

			// Traverse neighbors
			for i in [0: nbuts]
			{
				let x = x0 + buts[:,i];

				// Check if we are past the solution. We can't go backwards today
				if any(x > jlts_goal) continue;
				//println("x > jlts_goal = ", x > jlts_goal);
				//println("x  = ", x);
				//println("jg = ", jlts_goal);

				//let alt = dist0 + 1;
				let xg = jlts_goal - x;
				let alt = sum(xg * xg); // distance squared

				let xstr = str(x);
				let distx = get_dict_i64(&dist, xstr);
				if (distx < 0) distx = DIST_INFTY;
				if alt < distx
				{
					set_dict_i64(&dist, xstr, i64(alt));
					push_minheap_vec_i32(&q, [[alt, depth0+1], x]);
				}
			}
		}
		println("dist_end = ", dist_end);
		println();

		if dist_end == DIST_INFTY
		{
			println("Error: could not complete search");
			exit(1);
		}
		sum_ += dist_end;
		//exit(0);

		//let npress = 0;
		//let has_solution = false;
		//let x = [0; njlts];  // current position
		//while true
		//{
		//	npress += 1;  // no input is ever all [......] reachable in 0 presses

		//	let xg = jlts_goal - x;  // vector from x to goal
		//	println("x  = ", x);
		//	println("xg = ", xg);

		//	// Do dot products to figure out which button takes us closest
		//	// towards the goal from our current position
		//	//
		//	// This naive approach doesn't work
		//	let dotmax = 0;
		//	let imax = -1;
		//	for i in [0: nbuts]
		//	{
		//		let dot_ = sum(xg * buts[:,i]);
		//		println("dot_ = ", dot_);
		//		if dot_ > dotmax
		//		{
		//			dotmax = dot_;
		//			imax = i;
		//		}
		//	}
		//	println("dotmax, imax = ", [dotmax, imax]);

		//	x += buts[:,imax];

		//	if (npress == 20) exit(0);
		//	has_solution = all(x == jlts_goal);
		//	if (has_solution)
		//	{
		//		sum_ += npress;
		//		break;
		//	}

		//	//****************

		//	//let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

		//	//// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
		//	//let n = nbuts;
		//	//let k = npress;
		//	//while true {
		//	//	for i in [k: -1: 0] {
		//	//		if (pos[i] > n - 1)
		//	//		{
		//	//			pos[i-1] += 1;
		//	//			for j in [i: k+1]
		//	//				pos[j] = pos[j-1];
		//	//		}
		//	//	}
		//	//	if pos[0] > 0
		//	//		break;

		//	//	//println("pos = ", pos);

		//	//	// Apply button presses according to `pos` combination
		//	//	let state = [0; njlts];
		//	//	for p in pos[1: npress+1]
		//	//		state += buts[:,p];
		//	//	//println("state = ", state);
		//	//	if all(state == jlts_goal)
		//	//	{
		//	//		//println("**********************");
		//	//		//println("found solution");
		//	//		println("npress = ", npress);
		//	//		println();
		//	//		has_solution = true;
		//	//		break;
		//	//	}

		//	//	pos[k] += 1;
		//	//}

		//	//if (has_solution)
		//	//{
		//	//	sum_ += npress;
		//	//	break;
		//	//}
		//	////if (npress == 3) break; // TODO
		//}
		//println();
		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/10");

	let p1 = ""; let p2 = "";

	//p1 = part1(); // TODO
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

