
#include("../../utils.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		//println("words = ", words);

		let lits_str = words[0];
		//println("lits_str = ", lits_str);
		let nlits = len(lits_str) - 2;
		let lits_goal = vec_str(lits_str[1: nlits+1]) == "#";
		//println("lits_goal = ", lits_goal);

		let nbuts = size(words,0) - 2;
		//println("nbuts = ", nbuts);
		let buts = [false; nlits, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			//println("but_str = ", but_str);
			buts[parse_i32_delim(but_str, "(,)"), ib] = true;
		}
		//println("buts = ", buts);

		let npress = 0;
		let has_solution = false;
		while true
		{
			npress += 1;  // no input is ever all [......] reachable in 0 presses
			let pos = [0; npress+1]; // entry 0 is a dummy for the break condition

			// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C
			let n = nbuts;
			let k = npress;
			while true {
				for i in [k: -1: 0] {
					if (pos[i] > n - 1)
					{
						pos[i-1] += 1;
						for j in [i: k+1]
							pos[j] = pos[j-1];
					}
				}
				if (pos[0] > 0) break;
				//println("pos = ", pos);

				// Apply button presses according to `pos` combination
				let state = [false; nlits];
				for p in pos[1: npress+1]
					for i in [0: nlits]
						state[i] = state[i] != buts[i,p];
				//println("state = ", state);
				if all(state == lits_goal)
				{
					has_solution = true;
					break;
				}
				pos[k] += 1;
			}
			if (has_solution)
			{
				sum_ += npress;
				break;
			}
		}
		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn transpose_(a: [i32; :,:]): [i32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn transpose_f32(a: [f32; :,:]): [f32; :,:]
{
	let m = size(a,0);
	let n = size(a,1);
	let t = [0.0'f32; n, m];
	for i in [0: m]
	for j in [0: n]
		t[j,i] = a[i,j];
	return t;
}

fn matmul_vec_(mat: [f32; :,:], vec: [f32; :]): [f32; :]
{
	// Matrix-vector multiplication.  Return mat * vec
	let n = size(mat,0);
	let ans =  [0.0f; n];
	for     j in [0: size(mat,1)]
		for i in [0: size(mat,0)]
			ans[i] = ans[i] + mat[i,j] * vec[j];
	return ans;
}

fn ilp_solve(a: [i32; :,:], b: [i32; :]): [i32; :]
{
	println("a init = ", transpose_(a)); // transpose for sane display

	let m = i32(size(a,0));
	let n = i32(size(a,1));

	// Form augmented matrix tableau
	//let t = [0; m, n+1];
	let t = [0.0'f32; m, n+1];
	t[:, 0:n] = a;
	t[:, n] = b;
	println("t = ", transpose_f32(t));

	// Gaussian elimination to (reduced?) row echelon form
	let idx = [-1; m];   // save index of first non-zero in row after reduction
	let piv = [0: n];   // not used?
	let ifree = [0; n]; // list of free variables (over-allocated)
	let nfree = 0;
	let h = 0;
	let k = 0;
	while h < m and k < n
	{
		// Find pivot
		let imax = h;
		let amax = abs(t[h,k]);
		for i in [h+1: m]
			if abs(t[i,k]) > amax
			{
				amax = abs(t[i,k]);
				imax = i;
			}
		println("imax, amax = ", imax, amax);
		//if t[imax,k] == 0.0'f32
		if abs(t[imax,k]) < 1.e-3
		{
			ifree[nfree] = k;
			nfree += 1;
			k += 1;
		}
		else
		{
			idx[h] = k;

			// Swap rows h and imax
			t[[h, imax], :] = t[[imax, h], :];
			piv[[h, imax]] = piv[[imax, h]];

			for i in [h+1: m]  // REF. this is probably fine, and more efficient
			{
				if (i == h) continue;
				let f = t[i,k] / t[h,k];
				t[i,k] = 0.0'f32;
				for j in [k+1: n]
					t[i,j] -= t[h,j] * f;
			}
			h += 1;
			k += 1;
		}
	}
	println("t ref = ", transpose_f32(t));
	println("idx = ", idx);
	println("piv = ", piv);

	// Get the rest of the free vars
	for k in [m+1: n]
	{
		ifree[nfree] = k;
		nfree += 1;
	}
	ifree = ifree[0: nfree]; // trim
	println("nfree = ", nfree);
	println("ifree = ", ifree);

	//let ixmax = sum(b); // better upper bound?
	let ixmax = maxval(b);
	//ixmax += 5;
	println("ixmax = ", ixmax);

	// TODO: get fixed vars too?
	let nfixed = 0;
	let ifixed = [0; n];
	for k in [0: m]
	{
		if all(t[k,0:n] < 0.0001)
		{
			//ifree[nfree] = k;
			//nfree += 1;
			ifixed[nfixed] = k;
			nfixed += 1;
		}
	}
	//ifree = ifree[0: nfree]; // trim
	ifixed = ifixed[0: nfixed];
	println("ifixed = ", ifixed);

	let xopt = [0.0'f32; n];
	let fopt = 1.e20;

	// Iterate over possible value combinations of free vars
	//let combos = [0; ixmax+1];
	let combos = [0; nfree];
	while true
	{
		let x = [0.0'f32; n];
		//for i in [0: nfree]
		//	x[ifree[i]] = 1.0 * count(combos[1:ixmax+1] == i); // could be done more efficiently
		x[ifree] = combos;
		println("combos = ", combos);
		println("x[ifree] = ", x[ifree]);

		// Back substitute to solve for the other vars
		for i in [m-1: -1: -1]
		{
			//if (any(i == ifixed)) continue;
			//if (any(idx[i] == ifree)) continue;
			if (idx[i] < 0) continue;
			println("idx[i] = ", idx[i]);

			// TODO: helper var for idx[i]
			x[idx[i]] = t[i,n];
			for j in [idx[i]+1: n]
				x[idx[i]] -= t[i,j] * x[j];
			x[idx[i]] /= t[i, idx[i]];
		}
		let diff = sum(abs(matmul_vec_(t[:, 0:n], x) - t[:,n]));
		println("diff = ", diff);
		println("x = ", x);
		//break;
		//if (diff > 0.0001)
		//{
		//	println("Error: bad linear algebra solve");
		//	exit(1);
		//}

		// TODO: integer check?
		if (all(x >= -0.01))
		{
			//if (sum(x) > fopt) continue;
			if (sum(abs(x)) < fopt)
			{
				fopt = sum(abs(x));
				xopt = x;
			}
		}
		if not next_combo(&combos, ixmax)
			break;
		//next_combo(&combos, nfree, ixmax);
		//if combos[0] > 0
		//	break;
	}
	println("xopt = ", xopt);

	return i32(xopt);
}

fn next_combo(c: &[i32; :], n: i32): bool
{
	if all(c == n-1)
		return false;
	// Find first digit less than n-1
	let i = 0;
	while c[i] == n-1
	{
		c[i] = 0;
		i += 1;
	}
	c[i] += 1;
	return true;
}

fn next_combo_old(pos: &[i32; :], n: i32, k: i32)
{
	// TODO: one arg is redundant, related to size of pos
	//
	// Source: combinations with repetition:  https://rosettacode.org/wiki/Combinations_with_repetitions#C

	//let pos = [0; npress+1]; // entry 0 is a dummy for the break condition
	//let n = nbuts;
	//let k = npress;
	//while true {
		pos[k] += 1;
		for i in [k: -1: 0] {
			if (pos[i] > n - 1)
			{
				pos[i-1] += 1;
				for j in [i: k+1]
					pos[j] = pos[j-1];
			}
		}
		//if (pos[0] > 0) break;
		//println("pos = ", pos);

		//// Apply button presses according to `pos` combination
		//let state = [false; nlits];
		//for p in pos[1: npress+1]
		//	for i in [0: nlits]
		//		state[i] = state[i] != buts[i,p];
		////println("state = ", state);
		//if all(state == lits_goal)
		//{
		//	has_solution = true;
		//	break;
		//}
		//pos[k] += 1;
	//}
	//if (has_solution)
	//{
	//	sum_ += npress;
	//	break;
	//}
	return;
}

fn part2(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	let iline = 0;
	while not eof(f)
	{
		iline += 1;
		let words = split_(str_, " ");

		let jlts_str = words[size(words,0)-1];
		let jlts_goal = parse_i32_delim(jlts_str, "{,}");
		let njlts = size(jlts_goal,0);

		let nbuts = size(words,0) - 2;
		let buts = [0; njlts, nbuts];
		for ib in [0: nbuts]
		{
			let but_str = words[ib+1];
			buts[parse_i32_delim(but_str, "(,)"), ib] = 1;
		}
		//println("buts = ", buts);
		//println("jlts_goal = ", jlts_goal);

		let x = ilp_solve(buts, jlts_goal);
		println("x = ", x);

		sum_ += sum(x);
		break; // TODO

		println();
		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/10");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

