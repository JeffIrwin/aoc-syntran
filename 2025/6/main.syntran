
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let str_ = readln(f);
	let last_line = "";
	while not eof(f)
	{
		//println("str_ = ", str_);
		last_line = str_;

		str_ = readln(f);
	}
	close(f);
	//println("last_line = ", last_line);

	let t = i64(read_i32_mat_delim(filename, " +*"));
	t = t[:, 0: size(t,1)-1]; // trim last garbage line
	//println("t = ", t);

	let ops = split_(last_line, " ");
	//println("ops = ", ops);

	for x in [0: size(t,0)]
	{
		if (ops[x] == "+")
			sum_ += sum(t[x,:]);
		else if (ops[x] == "*")
			sum_ += product(t[x,:]);
		else
		{
			println("Error: bad operator");
			exit(-1);
		}
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let nlines = countln_(filename);
	//println("nlines = ", nlines);

	// Ignore operator line
	nlines -= 1;

	let lines = [""; nlines];

	let f = open(filename, "r");
	for i in [0: nlines]
	{
		lines[i] = readln(f);
		//println("line = ", lines[i]);
	}
	let ops_str = readln(f);
	close(f);
	//println("lines = ", lines);
	//println("ops_str = ", ops_str);

	let ops = split_(ops_str, " ");
	//println("ops = ", ops);

	let nops = size(ops, 0);
	//println("nops = ", nops);

	let col_start = 0;
	let col_end = 1;
	for iop in [0: nops]
	{
		// Scan to next operator
		if iop == nops-1
		{
			col_end = len(ops_str);
		}
		else
			while ops_str[col_end] == " "
				col_end += 1;
		//println("col_start = ", col_start);
		//println("ops_str slice = '", ops_str[col_start: col_end], "'");

		let res = 0'i64;
		if ops[iop] == "*"
			res = 1;
		//println("res initial = ", res);

		for col in [col_start: col_end]
		{
			let num_str = "";
			for line in lines
			{
				num_str += line[col];
			}
			//println("num_str = ", num_str);
			if (num_str == repeat(" ", i32(len(num_str)))) continue;

			let num = parse_i64(num_str);
			if ops[iop] == "*"
				res *= num;
			else
				res += num;

		}
		//println("res = ", res);
		sum_ += res;

		col_start = col_end;
		col_end += 1;
	}

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/6");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

