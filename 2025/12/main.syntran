
#include("../../utils.syntran");
#include("../../dict_i64.syntran");

// I had to cheat again today

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

// Global vars and constants
let nsx =  3;  // individual shape size
let nsy =  3;
let ns  =  6;  // number of shapes
let nt  =  8;  // number of rotation/flip transformation permutations
let nx  = -1;  // grid size
let ny  = -1;

let cache = new_dict_i64();

fn print_bool_mat(msg: str, b: [bool; :,:])
{
	println(msg);
	let nx = size(b,0);
	let ny = size(b,1);
	let c = ["."; nx, ny];
	for y in [0: ny]
	for x in [0: nx]
		if (b[x,y]) c[x,y] = "#";
	print_char_mat(&c);
	return;
}

fn bool_to_str(b: [bool; :,:]): str
{
	// Compact bool array to str conversion, for better hashmap keys
	let nx = size(b,0);
	let ny = size(b,1);
	let s = repeat(".", i32(nx*ny));
	let k = 0;
	for y in [0: ny]
	for x in [0: nx]
	{
		if (b[x,y]) s[k] = "#";
		k += 1;
	}
	return s;
}

fn transpose_(b: [bool; :,:]): [bool; :,:]
{
	let nx = size(b,0);
	let ny = size(b,1);
	let t = [false; ny, nx]; // transformed output
	for y in [0: ny]
	for x in [0: nx]
		t[y,x] = b[x,y];
	return t;
}

fn fliplr_(b: [bool; :,:]): [bool; :,:]
{
	let nx = size(b,0);
	let ny = size(b,1);
	let t = [false; nx, ny];
	for y in [0: ny]
	for x in [0: nx]
		t[nx-x-1, y] = b[x,y];
	return t;
}

fn flipud_(b: [bool; :,:]): [bool; :,:]
{
	let nx = size(b,0);
	let ny = size(b,1);
	let t = [false; nx, ny];
	for y in [0: ny]
	for x in [0: nx]
		t[x, ny-y-1] = b[x,y];
	return t;
}

fn trans_(b: [bool; :,:], i: i32): [bool; :,:]
{
	// Make 1 of 8 possible transformations (permutations of rotations and flips)
	if (i == 0) return b;                       // no transformation
	if (i == 1) return transpose_(b);           // main diagonal mirror
	if (i == 2) return fliplr_(b);              // left-right mirror
	if (i == 3) return flipud_(b);              // up-down mirror
	if (i == 4) return fliplr_(flipud_(b));     // rot 180
	if (i == 5) return fliplr_(transpose_(b));  // rot 270 ccw
	if (i == 6) return flipud_(transpose_(b));  // rot 90 ccw
	if (i == 7) return fliplr_(flipud_(transpose_(b))); // other diagonal mirror
}

fn part1(): str
{
	let sum_ = 0'i64;

	let nlines = countln_(filename);
	println("nlines = ", nlines);

	let shapes = [false; nsx, nsy, ns];

	let f = open(filename, "r");
	for i in [0: ns]
	{
		let str_ = readln(f); // ignore index line
		for y in [0: nsy]
		{
			str_ = readln(f);
			shapes[:,y,i] = vec_str(str_) == "#";
		}
		str_ = readln(f); // skip blank line
	}
	println("shapes = ", shapes);

	// Unit test
	let s0 = shapes[:,:,0];
	for i in [0: nt]
		print_bool_mat("s " + str(i) + " = ", trans_(s0, i));
	//print_bool_mat("s0 = ", s0);
	//print_bool_mat("tr(s0) = ", transpose_(s0));
	//print_bool_mat("lr(s0) = ", fliplr_(s0));
	//print_bool_mat("ud(s0) = ", flipud_(s0));
	//print_bool_mat("lr ud  = ", fliplr_(flipud_(s0)));
	//print_bool_mat("lr tr  = ", fliplr_(transpose_(s0)));
	//print_bool_mat("ud tr  = ", flipud_(transpose_(s0)));
	//print_bool_mat("lrudtr = ", fliplr_(flipud_(transpose_(s0))));

	let nblocks = [0; ns];
	for i in [0: ns]
		nblocks[i] = count(shapes[:,:,i]);
	println("nblocks = ", nblocks);

	for iproblem in [0: nlines - 5 * ns]
	{
		let str_ = readln(f);
		println("str_ = ", str_);

		let nums = parse_i32_delim(str_, "x: ");
		println("nums = ", nums);

		nx = nums[0]; // global size vars
		ny = nums[1];
		let nsv = nums[2: ns+2];
		println("nx, ny = ", [nx, ny]);
		println("nsv = ", nsv);

		let g = [false; nx, ny];

		// State contains:
		// - x pos
		// - y pos
		// - transformation index [0:8]
		// - shape type [0: 6]
		// - shape instance [0: nsv]
		let state = [0; 5]; // x, y, t, ist, isi

		// Find first non-zero nsv shape type
		let ist = 0;
		while (nsv[ist] == 0) ist += 1;
		state[3] = ist;
		println("ist = ", ist);

		// ARe you fucking kidding me rn
		//
		// Test input is not solvable like this but real input is
		let nb = sum(nblocks * nsv);
		println("nb = ", nb);

		if nb <= nx * ny
			sum_ += 1;

		//// I miscalculated the number of permutations and I thought that this
		//// would be explicitly solvable
		////
		//// I initiall thought there were nx * ny * nt * sum(nsv) permutations
		//// of ways to place parts, but it's actually more like 
		//// (nx * ny * nt) ** sum(nsv)
		////
		//// Not even the last line of the test input is calculatable like this

		//cache = new_dict_i64();
		//let is_packable = search(g, &shapes, nsv, state);
		//println("is_packable = ", is_packable);
		//if is_packable
		//	sum_ += 1;
		//exit(0);

		println();
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn search(g: [bool; :,:], shapes: &[bool; :,:,:], nsv: [i32; :], state: [i32; :]): bool
{
	// Should just pass isi and ist instead of mostly unused state array
	if (get_dict_i64(&cache, bool_to_str(g)) == 67) return false;
	//println("shape type     = ", ist);
	//println("shape instance = ", isi);
	//println("nx - nsx = ", nx - nsx);

	// Place the current shape in every possible pos and ori
	for x in [0: nx-nsx+1]
	for y in [0: ny-nsy+1]
	{
	//println("at pos ", [x, y]);
	//if (state[3] == 0) println("type 0 at pos ", [x, y]);
	//if (state[3] == 4 and state[4] == 0) println("shape 4.0 at pos ", [x, y]);
	//if (state[3] == 4 and state[4] == 1) println("shape 4.1 at pos ", [x, y]);
	for t in [0: nt]
	{
		let ist = state[3];
		let isi = state[4];

		let s = trans_(shapes[:,:,ist], t);
		//print_bool_mat("packing shape", s);
		if any(g[x: x+nsx, y: y+nsx] and s) continue; // not packable

		let gl = g; // local copy
		let statel = state;
		//print_bool_mat("before", g);
		gl[x: x+nsx, y: y+nsx] = g[x: x+nsx, y: y+nsx] or s;
		print_bool_mat("after", gl);

		// First increment shape instance `isi`
		if isi < nsv[ist]-1
		{
			statel[4] += 1;
			if search(gl, &shapes, nsv, statel) return true;
			continue;
		}
		statel[4] = 0;  // reset shape instance
	
		// Then increment shape type `ist`
		ist += 1;
		while true
		{
			if (ist >= ns) { println("done"); return true;} // done
			if (nsv[ist] != 0) break; // found next shape type to pack
			ist += 1;
		}
		statel[3] = ist;
		if search(gl, &shapes, nsv, statel) return true;
	}
	}

	// Cache this grid state as a known un-winnable situation
	set_dict_i64(&cache, bool_to_str(g), 67'i64);

	// Cache symmetric cases too
	for t in [1: nt]
	{
		let sgt = bool_to_str(trans_(g, t));
		set_dict_i64(&cache, sgt, 67'i64);
	}
	return false;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/12");

	let p1 = ""; let p2 = "";

	p1 = part1();
	// no part 2 on the last day

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

