
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

// Global vars and constants
let nsx =  3;  // individual shape size
let nsy =  3;
let ns  =  6;  // number of shapes
let nt  =  8;  // number of rotation/flip transformation permutations
let nx  = -1;  // grid size
let ny  = -1;

fn print_bool_mat(msg: str, b: [bool; :,:])
{
	println(msg);
	let nx = size(b,0);
	let ny = size(b,1);
	let c = ["."; nx, ny];
	for y in [0: ny]
	for x in [0: nx]
		if (b[x,y]) c[x,y] = "#";
	print_char_mat(&c);
	return;
}

fn transpose_(b: [bool; :,:]): [bool; :,:]
{
	let nx = size(b,0);
	let ny = size(b,1);
	let t = [false; ny, nx]; // transformed output
	for y in [0: ny]
	for x in [0: nx]
		t[y,x] = b[x,y];
	return t;
}

fn fliplr_(b: [bool; :,:]): [bool; :,:]
{
	let nx = size(b,0);
	let ny = size(b,1);
	let t = [false; ny, nx];
	for y in [0: ny]
	for x in [0: nx]
		t[nx-x-1, y] = b[x,y];
	return t;
}

fn flipud_(b: [bool; :,:]): [bool; :,:]
{
	let nx = size(b,0);
	let ny = size(b,1);
	let t = [false; ny, nx];
	for y in [0: ny]
	for x in [0: nx]
		t[x, ny-y-1] = b[x,y];
	return t;
}

fn trans_(b: [bool; :,:], i: i32): [bool; :,:]
{
	// Make 1 of 8 possible transformations (permutations of rotations and flips)
	if (i == 0) return b;
	if (i == 1) return transpose_(b);
	if (i == 2) return fliplr_(b);
	if (i == 3) return flipud_(b);
	if (i == 4) return fliplr_(flipud_(b));
	if (i == 5) return fliplr_(transpose_(b));
	if (i == 6) return flipud_(transpose_(b));
	if (i == 7) return fliplr_(flipud_(transpose_(b)));
}

fn part1(): str
{
	let sum_ = 0'i64;

	let nlines = countln_(filename);
	println("nlines = ", nlines);

	let shapes = [false; nsx, nsy, ns];

	let f = open(filename, "r");
	for i in [0: ns]
	{
		let str_ = readln(f); // ignore index line
		for y in [0: nsy]
		{
			str_ = readln(f);
			shapes[:,y,i] = vec_str(str_) == "#";
		}
		str_ = readln(f); // skip blank line
	}
	println("shapes = ", shapes);

	// Unit test
	let s0 = shapes[:,:,0];
	for i in [0: nt]
		print_bool_mat("s " + str(i) + " = ", trans_(s0, i));
	//print_bool_mat("s0 = ", s0);
	//print_bool_mat("tr(s0) = ", transpose_(s0));
	//print_bool_mat("lr(s0) = ", fliplr_(s0));
	//print_bool_mat("ud(s0) = ", flipud_(s0));
	//print_bool_mat("lr ud  = ", fliplr_(flipud_(s0)));
	//print_bool_mat("lr tr  = ", fliplr_(transpose_(s0)));
	//print_bool_mat("ud tr  = ", flipud_(transpose_(s0)));
	//print_bool_mat("lrudtr = ", fliplr_(flipud_(transpose_(s0))));

	for iproblem in [0: nlines - 5 * ns]
	{
		let str_ = readln(f);
		println("str_ = ", str_);

		let nums = parse_i32_delim(str_, "x: ");
		println("nums = ", nums);

		nx = nums[0]; // global size vars
		ny = nums[1];
		let nsv = nums[2: ns+2];
		println("nx, ny = ", [nx, ny]);
		println("nsv = ", nsv);

		let g = [false; nx, ny];

		// State contains:
		// - x pos
		// - y pos
		// - transformation index [0:8]
		// - shape type [0: 6]
		// - shape instance [0: nsv]
		let state = [0; 5]; // x, y, t, ist, isi

		// Find first non-zero nsv shape type
		let ist = 0;
		while (nsv[ist] == 0) ist += 1;
		state[3] = ist;
		println("ist = ", ist);

		let is_packable = search(g, &shapes, nsv, state);
		println("is_packable = ", is_packable);
		if is_packable
			sum_ += 1;

		//if (iproblem == 1) exit(0); // TODO
		exit(0); // TODO

		println();
	}
	close(f);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn search(g: [bool; :,:], shapes: &[bool; :,:,:], nsv: [i32; :], state: [i32; :]): bool
{
	//println("shape type     = ", ist);
	//println("shape instance = ", isi);

	//println("nx - nsx = ", nx - nsx);

	// Place the current shape in every possible pos and ori
	for x in [0: nx-nsx+1]
	for y in [0: ny-nsy+1]
	{
	//println("at pos ", [x, y]);
	//if (state[3] == 0) println("type 0 at pos ", [x, y]);
	if (state[3] == 4 and state[4] == 0) println("shape 4.0 at pos ", [x, y]);
	//if (state[3] == 4 and state[4] == 1) println("shape 4.1 at pos ", [x, y]);
	for t in [0: nt]
	{
		let ist = state[3];
		let isi = state[4];

		let s = trans_(shapes[:,:,ist], t);
		//print_bool_mat("packing shape", s);
		if any(g[x: x+nsx, y: y+nsx] and s) continue; // not packable

		let gl = g; // local copy
		let statel = state;
		print_bool_mat("before", g);
		gl[x: x+nsx, y: y+nsx] = g[x: x+nsx, y: y+nsx] or s;
		print_bool_mat("after", gl);

		// First increment shape instance `isi`
		//println("isi = ", isi);
		//println("ist = ", ist);
		//println("nsv = ", nsv);
		//println("nsv[ist] = ", nsv[ist]);
		if isi < nsv[ist]-1
		{
			statel[4] += 1;
			if search(gl, &shapes, nsv, statel) return true;
			//println("continue 1");
			continue;
			//return search(gl, &shapes, nsv, statel);
		}
		statel[4] = 0;  // reset shape instance
	
		// Then increment shape type `ist`
		//println("ist = ", ist);
		ist += 1;
		//println("ist = ", ist);
		//while (nsv[ist] == 0) ist += 1;
		while true
		{
			if (ist >= ns) { println("done"); return true;} // done
			if (nsv[ist] != 0) break; // found next shape type to pack
			ist += 1;
		}
		statel[3] = ist;
		if search(gl, &shapes, nsv, statel) return true;
		//println("continue 2");
		//return search(gl, &shapes, nsv, statel);
	}
	}
	return false;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/12");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

