
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let xy = read_i32_mat_delim(filename, ",");
	//println("xy = ", xy);

	let n = size(xy, 1);
	//println("n = ", n);
	for i in [0: n]
	for j in [0: i]
	{
		let a = product(abs(i64(xy[:,j]) - xy[:,i]) + 1);
		sum_ = max(sum_, a);
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let xy = read_i32_mat_delim(filename, ",");
	//println("xy = ", xy);

	let n = size(xy, 1);
	//println("n = ", n);

	// Get the unique x and y coordinates
	let xu = uniq(xy[0,:]);
	let yu = uniq(xy[1,:]);
	//println("xu = ", xu);
	//println("yu = ", yu);

	let xy0 = xy;  // backup original "exploded" coordinates

	// Compress the input points down to a smaller version of the same shape.
	// The smallest x coordinate will become 0, next smallest becomes 1, ...
	for i in [0: n]
	{
		// Compress x.  This could be done more optimally with a mapping array
		// if uniq() returned one
		let j = 0;
		while (xu[j] != xy[0,i]) j += 1;
		xy[0,i] = j;

		// Compress y
		j = 0;
		while (yu[j] != xy[1,i]) j += 1;
		xy[1,i] = j;
	}
	//println("xy (compressed) = ", xy);

	let xmin = minval(xy[0,:]);
	let ymin = minval(xy[1,:]);
	let xmax = maxval(xy[0,:]);
	let ymax = maxval(xy[1,:]);

	//println("x in ", [xmin, xmax]);
	//println("y in ", [ymin, ymax]);

	let nx = xmax + 1;
	let ny = ymax + 1;

	let g = [false; nx, ny];
	//println("marking red tiles ...");
	for i in [0: n]
		g[xy[0,i], xy[1,i]] = true;

	// Render green tiles on horizontal connecting lines between red tiles
	//println("marking horizontal lines ...");
	for i0 in [0: n]
	{
		let i1 = (i0 + 1) % n;
		//println("i0, i1 = ", [i0, i1]);

		let x0 = xy[0,i0];
		let x1 = xy[0,i1];
		if (x0 == x1) continue; // horizontal only here

		if x0 > x1
		{
			let tmp = x0;
			x0 = x1;
			x1 = tmp;
		}
		let y = xy[1,i0];
		g[x0+1: x1, y] = true;
	}

	let NCAP = 32; // TODO: check overflow. Or just don't use the sparse vrt
				   // line optimization now that we have spatial compression

	// Save a list of the vertical lines
	//println("getting vertical line list ...");
	let vrt = [0; 3, n];
	let nvrt = 0;
	let ixv = [-1; NCAP, nx]; // list of vrt line IDs at each x coord
	let nxv = [0; nx];
	for i0 in [0: n]
	{
		let i1 = (i0 + 1) % n;

		let y0 = xy[1,i0];
		let y1 = xy[1,i1];
		if (y0 == y1) continue; // vertical only

		let x = xy[0,i0];

		vrt[:, nvrt] = [x, y0, y1];
		ixv[nxv[x], x] = nvrt;
		nxv[x] += 1;
		nvrt += 1;
	}
	vrt = vrt[:, 0: nvrt]; // trim
	//println("vrt = ", vrt);

	// Instead of sorting, do a pigeonhole and make a list of each vrt at given
	// x coordinates

	// Go along horizontal scanlines, flipping the in/out state at every
	// vertical line, and render the green tiles inside the shape
	//println("rendering scanlines ...");
	for y in [0: ny]
	{
		//println("y = ", y, " / ", ny);
		let inside = false;
		for x in [0: nx]
		{
			if inside
				g[x,y] = true;

			for iv in ixv[0: nxv[x], x]
			{
				// Don't swap y start/end above but account for it here
				if (y < minval(vrt[[1,2], iv])) continue;
				if (y > maxval(vrt[[1,2], iv])) continue;
				if (y == vrt[1,iv]) continue;
				inside = not inside;  // flip state

				if inside
					g[x,y] = true;

				//println("x, y = ", [x, y]);
				//println("vrt iv = ", vrt[:,iv]);
				//println();
			}
		}
	}
	//println("g = ", g);

	// This is now the most expensive block
	//println("checking rectangles ...");
	for i in [0: n]
	for j in [0: i]
	{
		// [xy](hi|lo) exist in compressed space and are used for the in/out
		// logic
		let xlo = minval(xy[0, [i,j]]);
		let xhi = maxval(xy[0, [i,j]]);
		let ylo = minval(xy[1, [i,j]]);
		let yhi = maxval(xy[1, [i,j]]);

		if not all(g[xlo: xhi+1, ylo: yhi+1]) continue;

		// [xy](hi|lo)0 exist in original exploded space and are used only for
		// the final area calculation
		let xlo0 = minval(xy0[0, [i,j]]);
		let xhi0 = maxval(xy0[0, [i,j]]);
		let ylo0 = minval(xy0[1, [i,j]]);
		let yhi0 = maxval(xy0[1, [i,j]]);

		let a = i64(xhi0 - xlo0 + 1) * (yhi0 - ylo0 + 1);
		sum_ = max(sum_, a);
	}

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/9");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

