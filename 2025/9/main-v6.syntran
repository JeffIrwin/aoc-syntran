
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let xy = read_i32_mat_delim(filename, ",");
	//println("xy = ", xy);

	let n = size(xy, 1);
	println("n = ", n);
	for i in [0: n]
	for j in [0: i]
	{
		let a = product(abs(i64(xy[:,j]) - xy[:,i]) + 1);
		sum_ = max(sum_, a);
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let xy = read_i32_mat_delim(filename, ",");
	//println("xy = ", xy);

	let n = size(xy, 1);
	println("n = ", n);

	let xmin = minval(xy[0,:]);
	let ymin = minval(xy[1,:]);
	let xmax = maxval(xy[0,:]);
	let ymax = maxval(xy[1,:]);

	println("x in ", [xmin, xmax]);
	println("y in ", [ymin, ymax]);

	let nx = xmax + 1;
	let ny = ymax + 1;
	//nx += 2; // TODO: buffer for debugging only
	//ny += 2;

	//let g = [false; nx, ny];
	//println("done allocating g");
	//let set  = new_dict_i64();

	let NCAP = 32;

	let iyv = [-1; NCAP, ny]; // list of horizontal line IDs at each y coord
	let nyv = [0; ny];

	let hor = [0; 3, 8*ny];  // horizontal line list
	let nhor = 0;

	//println("marking red tiles ...");
	//for i in [0: n]  // mark the red tiles
	//{
	//	//g[xy[0,i], xy[1,i]] = true;
	//	set_dict_i64(&set, str(xy[:,i]), 1'i64);
	//}

	// Render green tiles on horizontal connecting lines between red tiles
	println("marking horizontal lines ...");
	for i0 in [0: n]
	{
		let i1 = (i0 + 1) % n;
		//println("i0, i1 = ", [i0, i1]);

		let x0 = xy[0,i0];
		let x1 = xy[0,i1];
		if (x0 == x1) continue; // horizontal only here

		if x0 > x1
		{
			let tmp = x0;
			x0 = x1;
			x1 = tmp;
		}

		let y = xy[1,i0];
		////g[x0+1: x1, y] = true;
		////set_dict_i64(&set, str(xy[:,i]), 1'i64);
		//for xl in [x0+1: x1]
		//	set_dict_i64(&set, str([xl, y]), 1'i64);

		hor[:, nhor] = [y, x0, x1];
		iyv[nyv[y], y] = nhor;
		nyv[y] += 1;
		nhor += 1;
		//vrt[:, nvrt] = [x, y0, y1];
		//ixv[nxv[x], x] = nvrt;
		//nxv[x] += 1;
		//nvrt += 1;
	}
	println("hor = ", hor[:, 0:nhor]);

	// Save a list of the vertical lines
	println("getting vertical line list ...");
	let vrt = [0; 3, n];
	let nvrt = 0;
	let ixv = [-1; NCAP, nx]; // list of vrt line IDs at each x coord
	let nxv = [0; nx];
	for i0 in [0: n]
	{
		let i1 = (i0 + 1) % n;

		let y0 = xy[1,i0];
		let y1 = xy[1,i1];
		if (y0 == y1) continue; // vertical only

		let x = xy[0,i0];

		vrt[:, nvrt] = [x, y0, y1];
		ixv[nxv[x], x] = nvrt;
		nxv[x] += 1;
		nvrt += 1;
	}
	vrt = vrt[:, 0: nvrt]; // trim
	println("vrt = ", vrt);

	// Instead of sorting, do a pigeonhole and make a list of each vrt at given
	// x coordinates

	// Go along horizontal scanlines, flipping the in/out state at every
	// vertical line, and render the green tiles inside the shape
	println("rendering scanlines ...");
	for y in [0: ny]
	{
		println("y = ", y, " / ", ny);
		let inside = false;
		for x in [0: nx]
		{
			//if inside
			//{
			//	//g[x,y] = true;
			//	set_dict_i64(&set, str([x,y]), 1'i64);
			//}

			//// Could sort vrt lines by x to optimize this part
			//if not any(x == vrt[0,:]) continue;
			//let iv = 0;
			//while (x != vrt[0,iv]) iv += 1;
			for iv in ixv[0: nxv[x], x]
			{
				// Don't swap y start/end above but account for it here
				if (y < minval(vrt[[1,2], iv])) continue;
				if (y > maxval(vrt[[1,2], iv])) continue;
				if (y == vrt[1,iv]) continue;
				inside = not inside;  // flip state

				//hor[:, nhor] = [y, x0, x1];
				//iyv[nyv[y], y] = nhor;
				//nyv[y] += 1;
				//nhor += 1;
				if inside
				{
					hor[:, nhor] = [y, x, nx+1];  // potentially replace ending nx+1 in else block
					iyv[nyv[y], y] = nhor;
					nyv[y] += 1;
					nhor += 1;
				}
				else
				{
					hor[2, nhor] = x+1;
					// don't increment on finish
				}

				//if inside
				//{
				//	//g[x,y] = true;
				//	set_dict_i64(&set, str([x,y]), 1'i64);
				//}
				//println("x, y = ", [x, y]);
				//println("vrt iv = ", vrt[:,iv]);
				//println();
			}
		}
	}
	println("hor = ", hor[:, 0:nhor]);

	//// Make char mat for debugging. TODO: comment for real input
	//let c = ["."; nx, ny];
	//for y in [0: ny]
	//{
	//	for x in [0: nx]
	//	{
	//		//let inside = get_dict_i64(&set, str([x,y])) == 1;
	//		let inside = false;
	//		//for iv in ixv[0: nxv[x], x]
	//		for iv in iyv[0: nyv[y], y]
	//		{
	//			//if (y < minval(vrt[[1,2], iv])) continue;
	//			//if (y > maxval(vrt[[1,2], iv])) continue;
	//			inside = hor[1,iv] <= x and x <= hor[2,iv];
	//			if (inside) break;
	//		}
	//		if (inside) c[x,y] = "#";
	//		//all_in = all_in and inside;
	//		//if (not all_in) break;
	//	}
	//	//if (not all_in) break;
	//}
	//print_char_mat(&c);
	//exit(0);

	//println("g = ", g);

	println("checking rectangles ...");
	for i in [0: n]
	{
	println("i = ", i, " / ", n);
	for j in [0: i]
	{
		let xlo = minval(xy[0, [i,j]]);
		let xhi = maxval(xy[0, [i,j]]);
		let ylo = minval(xy[1, [i,j]]);
		let yhi = maxval(xy[1, [i,j]]);

		//if any(g[xlo: xhi+1, ylo: yhi+1] == false) continue;
		let all_in = true;
		for y in [ylo: yhi+1]
		{
			for x in [xlo: xhi+1]
			{
				//let inside = get_dict_i64(&set, str([x,y])) == 1;
				let inside = false;
				//for iv in ixv[0: nxv[x], x]
				for iv in iyv[0: nyv[y], y]
				{
					//if (y < minval(vrt[[1,2], iv])) continue;
					//if (y > maxval(vrt[[1,2], iv])) continue;
					inside = hor[1,iv] <= x and x <= hor[2,iv];
					if (inside) break;
				}
				all_in = all_in and inside;
				if (not all_in) break;
			}
			if (not all_in) break;
		}

		//hor[:, nhor] = [y, x, -1];  // replace -1 in else block
		//iyv[nyv[y], y] = nhor;
		//nyv[y] += 1;
		//nhor += 1;
		//
		if (not all_in) continue;

		let a = i64(xhi - xlo + 1) * (yhi - ylo + 1);
		//let a = product(abs(i64(xy[:,j]) - xy[:,i]) + 1);
		sum_ = max(sum_, a);
	}
	}

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2025/9");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

