
#include("../../utils.syntran");

//==============================================================================

let ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

let NXMAS = 4;
let NCLAUSES_CAP = 8;  // 4 works for my input

let ACCEPT = -1;
let REJECT = -2;

//==============================================================================

fn part1(): i32
{
	// First pass: count fn and data lines
	let nfn = 0;
	let nda = 0;
	let f = open(filename);
	let str_ = readln(f);
	while not eof(f)
	{
		println("str_ = ", str_);

		if not (str_ == "")
		{
			if is_alpha(str_[0])
				nfn += 1;
			else
				nda += 1;
		}

		str_ = readln(f);
	}
	close(f);

	println("nfn = ", nfn);
	println("nda = ", nda);

	let fns       = [""; nfn];
	let fn_labels = [""; nfn];
	let bodies    = [""; nfn];

	let data = [-1; NXMAS, nda];

	// Second pass: save fns and data
	nfn = 0;
	nda = 0;
	f = open(filename);
	str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);

		if not (str_ == "")
		{
			if is_alpha(str_[0])
			{
				fns[nfn] = str_;

				let strs = split_(str_, "{}");
				fn_labels[nfn] = strs[0];

				bodies[nfn] = strs[1];

				nfn += 1;
			}
			else
			{
				let d = parse_i32_delim(str_, "{}xmas=,");

				data[0, nda] = d[0];
				data[1, nda] = d[1];
				data[2, nda] = d[2];
				data[3, nda] = d[3];

				nda += 1;
			}
		}

		str_ = readln(f);
	}
	close(f);

	//println("data = ", data);
	//println("fns  = ", fns);
	//println("fn_labels = ", fn_labels);
	//println("bodies = ", bodies);
	println();

	//let nclauses_max = 0;

	//let fn_clauses = [NCLAUSES_CAP, nfn];
	let xmas_idx = [-3; NCLAUSES_CAP, nfn];
	let ops      = [""; NCLAUSES_CAP, nfn];
	let comp_num = [-3; NCLAUSES_CAP, nfn];
	let fn_call  = [-3; NCLAUSES_CAP, nfn];
	let nclauses = [-3; nfn];

	// Compile fn bodies
	for i in [0: nfn]
	{
		let fn_label = fn_labels[i];
		let body = bodies[i];

		println("fn_label = ", fn_label);
		println("body = ", body);

		// If / else-if / else clauses
		let clauses = split_(body, ",");
		println("clauses = ", clauses);

		nclauses[i] = size(clauses, 0);
		//nclauses_max = max(nclauses_max, size(clauses, 0));

		for j in [0: nclauses[i] - 1]
		{
			let clause = clauses[j];
			let strs = split_(clause, "<>:");

			// Unpack from strs vector
			let xmas_str = strs[0];
			let op       = clause[1];  // removed by split_()
			let comp_str = strs[1];
			let call     = strs[2];

			println("xmas_str = ", xmas_str);
			println("op       = ", op      );
			println("comp_str = ", comp_str);
			println("call     = ", call    );
			println();

			xmas_idx[j, i] = scan("xmas", xmas_str);
			ops     [j, i] = op;
			comp_num[j, i] = parse_i32(comp_str);

			if call == "A"
			{
				fn_call[j, i] = ACCEPT;
			}
			else if call == "R"
			{
				fn_call[j, i] = REJECT;
			}
			else
			{
				// Scan for fn call label
				fn_call [j, i] = 0;
				while not (fn_labels[ fn_call[j, i] ] == call)
				{
					fn_call[j, i] += 1;
				}
			}
		}

		// handle else clause
		let j = nclauses[i] - 1;
		let call = clauses[j];
		if call == "A"
		{
			fn_call[j, i] = ACCEPT;
		}
		else if call == "R"
		{
			fn_call[j, i] = REJECT;
		}
		else
		{
			// Scan for fn call label
			fn_call [j, i] = 0;
			while not (fn_labels[ fn_call[j, i] ] == call)
			{
				fn_call[j, i] += 1;
			}
		}

		println();
	}
	//println("nclauses_max = ", nclauses_max);
	println("nclauses = ", nclauses);

	println("fn_call = ", fn_call);

	println("xmas_idx = ", xmas_idx);
	println("ops      = ", ops     );
	println("comp_num = ", comp_num);

	let in_call = 0;
	while not (fn_labels[ in_call ] == "in")
	{
		in_call += 1;
	}
	println("in_call = ", in_call);

	// Evaluate the fn calls on each line of data
	let sum_ = 0;
	for id in [0: nda]
	//for id in [0: 1]
	{
		let d =
			[
				data[0, id],
				data[1, id],
				data[2, id],
				data[3, id]
			];
		println("d = ", d);

		let i = in_call;
		let returned = false;
		while not returned
		{
			println("fn index = ", i);
			if i == ACCEPT
			{
				sum_ += d[0];
				sum_ += d[1];
				sum_ += d[2];
				sum_ += d[3];
				returned = true;
			}
			else if i == REJECT
			{
				returned = true;
			}
			else
			{
				let condition = false;
				let j = 0;
				while not returned and not condition and j < nclauses[i] - 1
				{
					println("clause index = ", j);
					let op   = ops     [j, i];
					let num  = comp_num[j, i];
					let xmas = xmas_idx[j, i];
					if op == "<"
						condition = d[xmas] < num;
					else // op == ">"
						condition = d[xmas] > num;
					j += 1;
				}
				if condition
					j -= 1;

				i = fn_call[j, i];
			}
		}
	}

	println("part 1 = ", sum_);
	sum_;
}

//==============================================================================

fn main()
{
	println();
	println("Starting AOC syntran main");

	part1();
	//part2();

	println("Ending AOC syntran main");
	println();
}

//==============================================================================

main();

//==============================================================================

