
#include("../../utils.syntran");

//==============================================================================

let ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): i32
{
	let sum_ = 0;

	// Get grid size
	let ny = countln_(filename);

	let f = open(filename);
	let str_ = readln(f);

	let nx = len(str_);

	//println("nx, ny = ", nx, ny);

	let grid  = [""; nx, ny];

	// Load the grid and find position of start S
	let xs = -1;
	let ys = -1;
	for y in [0: ny]
	{
		//println("str_ = ", str_);

		for x in [0: nx]
		{
			grid[x,y] = str_[x];
			if (grid[x,y] == "S")
			{
				xs = x;
				ys = y;
			}
		}
		str_ = readln(f);
	}
	close(f);

	//println("grid =");
	//println(grid);
	//println("xs, ys = ", xs, ", ", ys);

	// Start the search at S
	let x0 = xs;
	let y0 = ys;
	let x = -1;
	let y = -1;
	let x00 = -1;
	let y00 = -1;

	// Cardinal directions
	let dirs =
		[
			 1,  0, // east
			-1,  0, // west
			 0,  1, // south
			 0, -1  // north
			 ;
			 2,  4
		];
	//println("dirs = ", dirs);

	// Note consistent ordering with dirs array
	let EAST  = 0;
	let WEST  = 1;
	let SOUTH = 2;
	let NORTH = 3;

	let k = 0;
	//while x != xs or y != ys
	while not (x == xs and y == ys)
	//while not (x == xs and y == ys) and k < 4
	{
		//println("x0, y0 = ", x0, ", ", y0);
		let connects = false;
		let idir = 0;
		while not connects
		{
			x = x0 + dirs[0, idir];
			y = y0 + dirs[1, idir];

			//println("x, y = ", x, ", ", y);

			if (idir == EAST or idir == WEST)
			{
				// east-west pair
				let ce = grid[x0, y0];
				let cw = grid[x , y ];
				if (idir == EAST)
				{
					let tmp = ce;
					ce = cw;
					cw = tmp;
				}
				let cwe = cw + ce;
				//println("cw ce = ", cwe);

				//if (cw == "." or ce == ".")
				//{
				//	connects = false;
				//}

				//if (cw + ce == "--")
				//	connects = true;

				// | - L J 7 F . S
				connects = connects or cwe == "-7";
				connects = connects or cwe == "--";
				connects = connects or cwe == "-J";
				connects = connects or cwe == "-S";

				connects = connects or cwe == "L7";
				connects = connects or cwe == "L-";
				connects = connects or cwe == "LJ";
				connects = connects or cwe == "LS";

				connects = connects or cwe == "F7";
				connects = connects or cwe == "F-";
				connects = connects or cwe == "FJ";
				connects = connects or cwe == "FS";

				connects = connects or cwe == "S7";
				connects = connects or cwe == "S-";
				connects = connects or cwe == "SJ";
				connects = connects or cwe == "SS";

			}
			else
			{
				// north-south pair
				let cn = grid[x0, y0];
				let cs = grid[x , y ];
				if (idir == NORTH)
				{
					let tmp = cn;
					cn = cs;
					cs = tmp;
				}
				//println("cn, cs = ");
				//println(cn);
				//println(cs);

				let cns = cn + cs;

				// | - L J 7 F . S
				connects = connects or cns == "||";
				connects = connects or cns == "|L";
				connects = connects or cns == "|J";
				connects = connects or cns == "|S";

				connects = connects or cns == "7|";
				connects = connects or cns == "7L";
				connects = connects or cns == "7J";
				connects = connects or cns == "7S";

				connects = connects or cns == "F|";
				connects = connects or cns == "FL";
				connects = connects or cns == "FJ";
				connects = connects or cns == "FS";

				connects = connects or cns == "S|";
				connects = connects or cns == "SL";
				connects = connects or cns == "SJ";
				connects = connects or cns == "SS";
			}
			if (x == x00 and y == y00) connects = false;

			idir += 1;
		}

		x00 = x0;
		y00 = y0;

		x0 = x;
		y0 = y;

		k += 1;
		//println();
	}
	//println("max dist = ", k);
	sum_ = k / 2;

	println("part 1 = ", sum_);
	sum_;
}

//==============================================================================

fn part2(): i32
{
	let sum_ = 0;

	// Get grid size
	let ny = countln_(filename);

	let f = open(filename);
	let str_ = readln(f);

	let nx = len(str_);

	//println("nx, ny = ", nx, ny);

	let grid  = [""; nx, ny];

	// Load the grid and find position of start S
	let xs = -1;
	let ys = -1;
	for y in [0: ny]
	{
		//println("str_ = ", str_);

		for x in [0: nx]
		{
			grid[x,y] = str_[x];
			if (grid[x,y] == "S")
			{
				xs = x;
				ys = y;
			}
		}
		str_ = readln(f);
	}
	close(f);

	//println("grid =");
	//println(grid);
	//println("xs, ys = ", xs, ", ", ys);

	// Start the search at S
	let x0 = xs;
	let y0 = ys;
	let x = -1;
	let y = -1;
	let x00 = -1;
	let y00 = -1;

	// Cardinal directions
	let dirs =
		[
			 1,  0, // east
			-1,  0, // west
			 0,  1, // south
			 0, -1  // north
			 ;
			 2,  4
		];
	//println("dirs = ", dirs);

	// Note consistent ordering with dirs array
	let EAST  = 0;
	let WEST  = 1;
	let SOUTH = 2;
	let NORTH = 3;

	// c.f. cali.f90
	let wind  = [ 0; nx, ny];
	let first = true;
	let defer = false;
	let wind_inc0 = 0;
	let xd = -1;
	let yd = -1;
	let wind_incd = 0;

	// bool arrays for points that are on/in contour.  shouldn't be necessary if
	// i can count edges correctly
	let on       = [false; nx, ny];
	let on_or_in = [false; nx, ny];

	//println("reverse_str(aoeu) = ", reverse_str("aoeu"));

	let k = 0;
	while not (x == xs and y == ys)
	{
		//println("x0, y0 = ", x0, ", ", y0);
		let connects = false;
		let idir = 0;
		while not connects
		{
			x = x0 + dirs[0, idir];
			y = y0 + dirs[1, idir];

			//println("x, y = ", x, ", ", y);

			if (idir == EAST or idir == WEST)
			{
				// east-west pair
				let cwe = grid[x0, y0] + grid[x, y];
				if (idir == WEST)
					cwe = reverse_str(cwe);
				//println("cw ce = ", cwe);

				// | - L J 7 F . S
				connects = connects or cwe == "-7";
				connects = connects or cwe == "--";
				connects = connects or cwe == "-J";
				connects = connects or cwe == "-S";

				connects = connects or cwe == "L7";
				connects = connects or cwe == "L-";
				connects = connects or cwe == "LJ";
				connects = connects or cwe == "LS";

				connects = connects or cwe == "F7";
				connects = connects or cwe == "F-";
				connects = connects or cwe == "FJ";
				connects = connects or cwe == "FS";

				connects = connects or cwe == "S7";
				connects = connects or cwe == "S-";
				connects = connects or cwe == "SJ";
				connects = connects or cwe == "SS";

			}
			else
			{
				// north-south pair
				let cns = grid[x0, y0] + grid[x , y ];
				if (idir == NORTH)
					cns = reverse_str(cns);

				// | - L J 7 F . S
				connects = connects or cns == "||";
				connects = connects or cns == "|L";
				connects = connects or cns == "|J";
				connects = connects or cns == "|S";

				connects = connects or cns == "7|";
				connects = connects or cns == "7L";
				connects = connects or cns == "7J";
				connects = connects or cns == "7S";

				connects = connects or cns == "F|";
				connects = connects or cns == "FL";
				connects = connects or cns == "FJ";
				connects = connects or cns == "FS";

				connects = connects or cns == "S|";
				connects = connects or cns == "SL";
				connects = connects or cns == "SJ";
				connects = connects or cns == "SS";
			}
			if (x == x00 and y == y00) connects = false;

			idir += 1;
		}

		// Set winding values for filling.  Reference:
		//
		//     https://github.com/JeffIrwin/cali/blob/e7971fa48a79be46e1475f6c5e6f60757faf7b08/src/cali.f90#L1179-L1199
		//
		let wind_inc = sign_(y - y0);
		if (not first and wind_inc != 0)
		{
			if (wind_inc0 == 0 and not defer)
			{
				defer = true;
				xd = x0;
				yd = y0;
				wind_incd = wind_inc;
			}

			if (wind_inc0 + wind_inc == 0)
				wind[x0, y0] += wind_inc;

			wind[x, y] += wind_inc;
			wind_inc0   = wind_inc;
		}
		first = false;

		on_or_in[x, y] = on_or_in[x, y] or true;
		on      [x, y] = on      [x, y] or true;

		x00 = x0;
		y00 = y0;

		x0 = x;
		y0 = y;

		k += 1;
		//println();
	}

	// Mark the deferred point after wrapping around the entire contour
	if (defer and wind_incd != wind_inc0)
		wind[xd, yd] += wind_incd;

	//println("wind = ");
	//println(wind);

	//// Unit tests
	//println("sign_(0) = ", sign_(0));
	//println("sign_( 1) = ", sign_( 1));
	//println("sign_(-1) = ", sign_(-1));
	//println("sign_( 2) = ", sign_( 2));
	//println("sign_(-2) = ", sign_(-2));

	// Count all points/pixels that are in *or on* the pipe contour
	let n = 0;
	for y in [0: ny]
	{
		let wind_num = 0;
		for x in [0: nx]
		{
			wind_num += wind[x, y];
			//if (wind_num != 0 or wind[x, y] != 0) n += 1;

			if (wind_num != 0)
			{
				n += 1; // count of `n` isn't right bc it doesn't count east edges
				on_or_in[x, y] = on_or_in[x, y] or true;
			}
		}
	}
	//println("num on or in = ", n);
	//println("num on       = ", k);

	//// This should be right if i count east edges
	//sum_ = n - k;

	sum_ = 0;
	for y in [0: ny]
	for x in [0: nx]
		if (on_or_in[x,y] and not on[x,y]) sum_ += 1;

	println("part 2 = ", sum_);
	sum_;
}

//==============================================================================

fn main()
{
	println();
	println("Starting AOC syntran main");

	part1();
	part2();

	println("Ending AOC syntran main");
	println();
}

//==============================================================================

main();

//==============================================================================

