
#include("../../utils.syntran");

//==============================================================================

let ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let NDIM = 2;        // spatial dimensions
//let NST  = NDIM + 1; // space-time dimensions

let NDIRS = 4;

// Cardinal directions
let DIRS =
	[
		 0, -1, // north
		-1,  0, // west
		 0,  1, // south
		 1,  0  // east
		 ;
		 2,  NDIRS
	];
//println("DIRS = ", DIRS);

// Note consistent ordering with DIRS array
let NORTH = 0;
let WEST  = 1;
let SOUTH = 2;
let EAST  = 3;

let DIRS_STR = "^<v>";

// Number of state variables.  State contains:
//
//     0. dist ("heat loss")
//     1. x pos
//     2. y pos
//     3. direction (encoded as a single i32 from enum above)
//     4. length of straight line
//
// Obviously the state has to contain [x,y] pos at the very least.  I had tried
// separately to add direction to the state, and also total number of search
// steps (not exactly the same as distance or length).  The trick is to save
// both direction *and* length in the state.  I wouldn't have figured this out
// without looking at hyper-neutrino's solution:
//
//     https://github.com/hyper-neutrino/advent-of-code/blob/main/2023/day17p1.py
//
let NSTATE = 5;

// Queue data structure.  I don't have pass-by-reference but I do have
// pass-by-global-variable :)
let QUEUE_CAP = 2 * 1024 * 1024;
let queue = [-1; NSTATE, QUEUE_CAP];
let queue_beg  = 0;
let queue_end  = 0;
let queue_end0 = 0;

//let unvisited = [true; 0, 0, 0, 0];

//****************

fn push_(v: [i32; :])
{
	//println("pushing ", v);
	if queue_end >= QUEUE_CAP
	{
		println();
		println("Error: QUEUE_CAP overflow!");
		println();
	}

	queue[0, queue_end ] = v[0]; //dist;
	queue[1, queue_end ] = v[1]; //x;
	queue[2, queue_end ] = v[2]; //y;
	queue[3, queue_end ] = v[3]; //dir;
	queue[4, queue_end ] = v[4]; //len_;

	queue_end += 1;
}

//****************

fn sort_queue()
{
	// bubble sort :(
	//
	// TODO: try iterative quick sort, e.g.
	//
	//    https://www.geeksforgeeks.org/iterative-quick-sort/
	//
	// Scroll about halfway down that page for the iterative (not recursive)
	// version

	println("starting sort_queue()");

	let swapped = true;
	while swapped
	{
		swapped = false;
		for i in [queue_beg + 1: queue_end]
		{
			if queue[0, i-1] > queue[0, i]
			{
				for j in [0: NSTATE]
				{
					let tmp       = queue[j, i-1];
					queue[j, i-1] = queue[j, i];
					queue[j, i  ] = tmp;
				}
				swapped = true;
			}
		}
	}

	// This could also prune popped elements entirely to avoid QUEUE_CAP issues
	while queue[0, queue_beg] < 0 and queue_beg < queue_end
		queue_beg += 1;

	// After sorting, new unsorted elements will be pushed onto the queue after
	// this position
	queue_end0 = queue_end;
}

//****************

let pop_count = 0;
fn pop_(): [i32; :]
{
	// Linear scan because I'm not implementing a min-heap queue :(

	// queue_beg is guaranteed to be in the queue (i think)
	let i = queue_beg;
	let imin = i;
	let min_ = queue[0,i];

	// Scan only the unsorted part of the queue
	let x = [-1; NSTATE];
	i = queue_end0;  // TODO
	//i = queue_beg; // TODO: benchmark compared to i = queue_beg
	while i < queue_end
	{
		if queue[0,i] >= 0
		{
			if queue[0,i] < min_ //or min_ < 0
			{
				min_ = queue[0,i];
				imin = i;
			}
		}
		i += 1;
	}
	x[0] = queue[0,imin];
	x[1] = queue[1,imin];
	x[2] = queue[2,imin];
	x[3] = queue[3,imin];
	x[4] = queue[4,imin];

	queue[0, imin] = -1;  // mark popped element as out of queue

	// When queue[0,:] happens to get popped, increment it to the next element
	// still in queue
	//if imin == queue_beg
		while queue[0, queue_beg] < 0 and queue_beg < queue_end
			queue_beg += 1;

	//// I don't actually know if sorting the queue provides any perf benefit.
	//// Even if it does, the sort period should be tuned to the specific
	//// problem based on vibes

	//if pop_count % 10000 == 0
	//if pop_count % 5000 == 0
	if pop_count % 3000 == 0 // TODO
	//if pop_count % 1000 == 0
	//if pop_count % 100 == 0
	//if pop_count % 1 == 0
	{
		sort_queue();
	}

	pop_count += 1;
	let ans = x;
}

//==============================================================================

fn dijkstra(map: [i32; :, :], xbeg: [i32; :], xend: [i32; :], len_min: i32, len_max: i32): i32
{
	println();
	println("starting dijkstra()");
	println("xbeg = ", xbeg);
	println("xend = ", xend);
	println("len_min = ", len_min);
	println("len_max = ", len_max);

	queue_beg  = 0;
	queue_end  = 0;
	queue_end0 = 0;
	queue = [-1; NSTATE, QUEUE_CAP];

	let nx = size(map, 0);
	let ny = size(map, 1);

	println("nx, ny = ", [nx, ny]);

	// initialize distance to practical infinity.  using a negative with extra
	// logic might be more robust
	let DIST_INFTY = 2000000000;
	//let DIST_INFTY = -1;

	let dist = [DIST_INFTY; nx, ny, NDIRS+1, len_max];
	let unvisited = [true ; nx, ny, NDIRS+1, len_max];

	// Initialize source vertex to 0 distance

	//dist[xbeg[0], xbeg[1], EAST, 0] = 0;
	//push_([0, xbeg[0], xbeg[1], EAST, 0]);
	dist  [   xbeg[0], xbeg[1], NDIRS, 0] = 0;
	push_([0, xbeg[0], xbeg[1], NDIRS, 0]);

	let dist0 = -1;

	let found = false;
	let dist_end = DIST_INFTY;
	while not found
	{
		// u is vertex in unvisited with min dist
		let u = pop_();

		println("u = ", u);
		//if u[0] > dist0
		//{
		//	println("u = ", u);
		//	dist0 = u[0];
		//}

		//if u[1] == xend[0] and u[2] == xend[1]
		if u[1] == xend[0] and u[2] == xend[1] and u[4] >= len_min
		{
			found = true;
			dist_end = u[0];
			println("dist end = ", dist_end);
		}

		// Remove u from unvisited
		//println("removing");
		unvisited[u[1], u[2], u[3], u[4]] = false;
		//println("done");

		// For each neighbor v of u still in unvisited
		for dir in [0: NDIRS]
		{
			let v =
				[
					0, // dist and len will be set later
					u[1] + DIRS[0, dir],
					u[2] + DIRS[1, dir],
					dir,
					0
				];

			let continue_ = false;

			// Check bounds
			if v[1] < 0 or v[1] >= nx or v[2] < 0 or v[2] >= ny
				continue_ = true;

			// Straight line path length must be less than ~3 or 4 (depending on
			// how len_ is initialized)
			let len_ = 1;
			let dir0 = u[3];
			//println("continue_ = ", continue_);
			if not continue_
			{
				if dir  == dir0
				{
					len_ = u[4] + 1;
				}
				//if (len_ < len_min) and (dir != dir0) and (dir0 != NDIRS)
				//if (len_ < len_min) and (dir == dir0) and (dir0 != NDIRS)
				if (len_ < len_min) and (dir == dir0) and (dir0 != NDIRS)
				{
					//println("len_ < len_min = ", len_, " < ", len_min);
					//println("dir, dir0 = ", [dir, dir0]);
					continue_ = true;
				}
				if (len_ >= len_max) and (dir0 != NDIRS)
				{
					continue_ = true;
				}
				v[4] = len_;
			}
			//println("continue_ = ", continue_);

			// v still in unvisited
			//println("checking");
			if not continue_
				if not unvisited[v[1], v[2], v[3], v[4]]
					continue_ = true;
			//println("done");

			// ban immediate 2 cycle backtracking but allow looping of 3+ cycle
			if not continue_
			{
				// should be possible to do this with a single `+ 2 % 4` expression
				continue_ =
					(dir == EAST  and dir0 == WEST ) or
					(dir == WEST  and dir0 == EAST ) or
					(dir == NORTH and dir0 == SOUTH) or
					(dir == SOUTH and dir0 == NORTH);
			}

			// Graph distances are stored in map array
			if not continue_
			{
				let alt = u[0] + map[v[1], v[2]];
				//if  alt < dist[v[1], v[2], v[3], v[4]] or dist[v[1], v[2], v[3], v[4]] < 0
				if  alt < dist[v[1], v[2], v[3], v[4]]
				{
					v[0] = alt;
					push_(v);
					dist[v[1], v[2], v[3], v[4]] = alt;
				}
			}
		}
	}
	//println("dirs = ", dirs);

	let ans = dist_end;
}

//==============================================================================

fn dijkstra2(map: [i32; :, :], xbeg: [i32; :], xend: [i32; :], len_min: i32, len_max: i32): i32
{
	// Directly adapted from:  https://github.com/hyper-neutrino/advent-of-code/blob/main/2023/day17p2.py

	println();
	println("starting dijkstra2()");
	println("xbeg = ", xbeg);
	println("xend = ", xend);
	println("len_min = ", len_min);
	println("len_max = ", len_max);

	queue_beg  = 0;
	queue_end  = 0;
	queue_end0 = 0;
	queue = [-1; NSTATE, QUEUE_CAP];

	let nx = size(map, 0);
	let ny = size(map, 1);

	println("nx, ny = ", [nx, ny]);

	// initialize distance to practical infinity.  using a negative with extra
	// logic might be more robust
	let DIST_INFTY = 2000000000;
	//let DIST_INFTY = -1;

	let dist = [DIST_INFTY; nx, ny, NDIRS+1, len_max];
	let unvisited = [true ; nx, ny, NDIRS+1, len_max];

	// Initialize source vertex to 0 distance

	//dist[xbeg[0], xbeg[1], EAST, 0] = 0;
	//push_([0, xbeg[0], xbeg[1], EAST, 0]);
	dist  [   xbeg[0], xbeg[1], NDIRS, 0] = 0;
	push_([0, xbeg[0], xbeg[1], NDIRS, 0]);

	let dist_progress = -1;

	let found = false;
	let dist_end = DIST_INFTY;
	while not found
	{
		let u = pop_();
		//println("u = ", u);

		// unpack from array
		let dist0 = u[0];
		let x0    = u[1];
		let y0    = u[2];
		let dir0  = u[3];
		let len0  = u[4];

		if dist0 > dist_progress
		{
			dist_progress = dist0;
			println("u = ", u);
		}

		if x0 == xend[0] and y0 == xend[1] and len0 >= len_min
		{
			found = true;
			dist_end = dist0;
			println("dist_end = ", dist_end);
		}
		
		let continue_ = false;

		if not unvisited[x0, y0, dir0, len0]
			continue_ = true;

		if not continue_
			unvisited[x0, y0, dir0, len0] = false;

		if not continue_
			if len0 < len_max-1 and dir0 != NDIRS
			{
				let x = x0 + DIRS[0, dir0];
				let y = y0 + DIRS[1, dir0];
				if 0 <= x and x < nx and 0 <= y and y < ny
				{
					// The alt calculation and dist comparison could be
					// refactored inside of push_(), at the cost of scanning to
					// see if a value with larger dist already exists.  This way
					// should be more efficient (at least, if I don't use an
					// actual priority queue)

					let alt = dist0 + map[x,y];
					if alt < dist[x, y, dir0, len0 + 1]
					{
						push_([dist0 + map[x,y], x, y, dir0, len0 + 1]);
						dist[x, y, dir0, len0 + 1] = alt;
					}
				}
			}

		if not continue_
			if len0 >= len_min or dir0 == NDIRS
				for dir in [0: NDIRS]
					if dir != dir0 and ((dir + 2) % 4) != dir0
					{
						let x = x0 + DIRS[0, dir];
						let y = y0 + DIRS[1, dir];
						if 0 <= x and x < nx and 0 <= y and y < ny
						{
							let alt = dist0 + map[x,y];
							if alt < dist[x, y, dir, 1]
							{
								push_([dist0 + map[x,y], x, y, dir, 1]);
								dist[x, y, dir, 1] = alt;
							}
						}
					}
	}
	let ans = dist_end;
}

//==============================================================================

fn part1(): i32
{
	let ny = countln_(filename);

	let f = open(filename);
	let str_ = readln(f);

	let nx = len(str_);

	println("nx, ny = ", [nx, ny]);

	let grid = [-1; nx, ny];

	for y in [0: ny]
	{
		//println("str_ = ", str_);

		for x in [0: nx]
			grid[x, y] = parse_i32(str_[x]);

		str_ = readln(f);
	}
	close(f);

	println("grid = ", grid);

	// Start at northwest corner, end at southeast
	let xbeg = [0, 0];
	let xend = [nx - 1, ny - 1];

	//let sum_ = dijkstra(grid, xbeg, xend, 0, 4);
	let sum_ = dijkstra2(grid, xbeg, xend, 0, 4);

	println("part 1 = ", sum_);
	//println("hint: 1255 was too low");

	//println("grid = ", grid);

	sum_;
}


//==============================================================================

fn part2(): i32
{
	let ny = countln_(filename);

	let f = open(filename);
	let str_ = readln(f);

	let nx = len(str_);

	println("nx, ny = ", [nx, ny]);

	let grid = [-1; nx, ny];

	for y in [0: ny]
	{
		//println("str_ = ", str_);

		for x in [0: nx]
			grid[x, y] = parse_i32(str_[x]);

		str_ = readln(f);
	}
	close(f);

	//println("grid = ", grid);

	// Start at northwest corner, end at southeast
	let xbeg = [0, 0];
	let xend = [nx - 1, ny - 1];

	let sum_ = dijkstra2(grid, xbeg, xend, 4, 11);

	println("part 2 = ", sum_);
	//println("grid = ", grid);

	sum_;
}

//==============================================================================

fn main()
{
	println();
	println("Starting AOC syntran main");

	//part1(); // TODO: takes ~30 minutes to run
	part2();

	println("Ending AOC syntran main");
	println();
}

//==============================================================================

main();

//==============================================================================

