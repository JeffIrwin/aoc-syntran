
#include("../../utils.syntran");

//==============================================================================

let ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

// WARNING: syntran has memory leaks where it does not deallocate local fn
// arrays after they go out of scope.  Running this code on the real input with
// 1000 hands to be sorted will leak over 16 GB memory

fn count_eq(v: [i32; :], x: i32): i32
{
	// How many elements of a vector `v` are equal to a scalar `x`?
	let n = 0;
	for i in [0: size(v,0)]
		if (v[i] == x) n += 1;
	let ans = n;
}

fn get_counts2(a: str): [i32; :]
{
	// Different than part1

	//println();
	//println("starting get_counts2");
	//println("hand = ", a);

	let n = 5;
	let marked  = [false; n];
	let counts_ = [1; n];

	for i in [0: n]
	{
		// Ignore wild jokers for the regular count
		if not (a[i] == "J")
		{
			for j in [i+1: n]
			{
				if a[i] == a[j] and not marked[j]
				{
					counts_[i] += 1;
					marked [j] = true;
				}
			}
			if marked[i]
				counts_[i] = 0;
		}
	}
	//println("counts_ = ", counts_);
	//println();

	// Count wild jokers
	let count_j = 0;
	for i in [0: n]
		if (a[i] == "J") count_j += 1;

	//println("regular counts_ = ", counts_);
	//println("joker   count   = ", count_j);

	// Get the max loc of the counts_.  c.f. Fortran's `maxloc()`
	let imax = 0;
	for i in [0: n]
		if (counts_[i] > counts_[imax]) imax = i;

	//println("max loc         = ", imax);

	if count_j == n
		// If we have 5 jokers, it's just five of a kind
		counts_[0] = n;
	else
		counts_[imax] += count_j;

	//println("wild    counts_ = ", counts_);

	// return
	let ans = counts_;
}

// Types of hands enum
let HIGH_CARD = 0;
let ONE_PAIR  = 1;
let TWO_PAIR  = 2;
let TRIPLET   = 3;
let FULL_HAUS = 4;
let QUAD      = 5;
let PENT      = 6;

// Strength of card enum (for breaking near-ties)
//
// These enums are different than part1, making it difficult to unify into the
// same syntran file with global vars :(
let STR_A  = 12;
let STR_K  = 11;
let STR_Q  = 10;
//let STR_J  =  9;  // TODO: uncomment and try unifying w/ part 1 main.syntran
let STR_T  =  8;
let STR_9  =  7;
let STR_8  =  6;
let STR_7  =  5;
let STR_6  =  4;
let STR_5  =  3;
let STR_4  =  2;
let STR_3  =  1;
let STR_2  =  0;
let STR_J2 = -1;

fn get_strength2(c: str): i32
{
	let strength = -1;
	if (c == "A") strength = STR_A;
	if (c == "K") strength = STR_K;
	if (c == "Q") strength = STR_Q;
	if (c == "J") strength = STR_J2; // different than part 1
	if (c == "T") strength = STR_T;
	if (c == "9") strength = STR_9;
	if (c == "8") strength = STR_8;
	if (c == "7") strength = STR_7;
	if (c == "6") strength = STR_6;
	if (c == "5") strength = STR_5;
	if (c == "4") strength = STR_4;
	if (c == "3") strength = STR_3;
	if (c == "2") strength = STR_2;

	let ans = strength;
}

fn type_to_str(t: i32): str
{
	let str_ = "";
	if (t == HIGH_CARD) str_ = "HIGH_CARD" ;
	if (t == ONE_PAIR ) str_ = "ONE_PAIR"  ;
	if (t == TWO_PAIR ) str_ = "TWO_PAIR"  ;
	if (t == TRIPLET  ) str_ = "TRIPLET"   ;
	if (t == FULL_HAUS) str_ = "FULL_HAUS" ;
	if (t == QUAD     ) str_ = "QUAD"      ;
	if (t == PENT     ) str_ = "PENT"      ;

	let ans = str_;
}

fn get_type2(a: str): i32
{
	let counts_ = get_counts2(a);

	//let type_ = -1;
	let type_ = HIGH_CARD;

	if (count_eq(counts_, 2) == 1) type_ = ONE_PAIR;
	if (count_eq(counts_, 5) == 1) type_ = PENT;
	if (count_eq(counts_, 4) == 1) type_ = QUAD;
	if (count_eq(counts_, 3) == 1) type_ = TRIPLET;
	if (count_eq(counts_, 3) == 1 and count_eq(counts_, 2) == 1) type_ = FULL_HAUS;
	if (count_eq(counts_, 2) == 2) type_ = TWO_PAIR;

	let ans = type_;
}

fn is_hand_gt2(a: str, b: str): bool
{
	// Is hand `a` greater than hand `b`?

	//println("starting is_hand_gt2()");
	//println("a = """, a, """");
	//println("b = """, b, """");

	//let n = 5;
	//let ca = get_counts2(a);
	//let cb = get_counts2(b);

	//println("count_eq(ca, 3) = ", count_eq(ca, 3));
	//println("count_eq(ca, 2) = ", count_eq(ca, 2));
	//println("count_eq(ca, 1) = ", count_eq(ca, 1));

	let ta = get_type2(a);
	let tb = get_type2(b);

	//println("ta, tb = ", ta, ", ", tb);

	let gt = true;
	if tb > ta
	{
		gt = false;
	}
	else if tb == ta
	{
		let i = 0;
		while a[i] == b[i]
			i += 1;

		gt = get_strength2(a[i]) > get_strength2(b[i]);

		//println("tie break: ", a[i], " >? ", b[i], " == ", gt);
	}

	//println("gt = ", gt);
	//println();

	let ans = gt;
}

//==============================================================================

fn bubble_sort_hands(hands: [str; :]): [i32; :]
{
	//println("starting bubble_sort_hands()");

	let n = size(hands, 0);
	let idx = [0: n];

	let swapped = true;
	while swapped
	{
		swapped = false;
		for i in [1: n]
		{
			if is_hand_gt2(hands[idx[i-1]], hands[idx[i]])
			{
				// swap idx[i-1] and idx[i]
				let tmp = idx[i-1];
				idx[i-1] = idx[i];
				idx[i] = tmp;

				swapped = true;
				//println("swapped = ", swapped);
			}
		}
		//println("end swapped = ", swapped);
	}

	//println("ending bubble_sort_hands()");
	//println();

	let ans = idx;
	//idx;
}

//==============================================================================

fn part2(): i32
{
	let sum_ = 0;

	let n = countln_(filename);
	println("n = ", n);

	let hands = [""; n];
	let bids  = [0 ; n];

	let f = open(filename, "r");
	for i in [0: n]
	{
		let str_ = readln(f);
		//println("str_ = ", str_);

		let strs = split_(str_, " ");
		hands[i] = strs[0];
		bids [i] = parse_i32(strs[1]);

		println("hand, type = ", hands[i], ", ", type_to_str(get_type2(hands[i])));

	}
	close(f);

	//println("hands = ", hands);
	//println("bids  = ", bids);

	//// Unit test for hand comparison
	//let h1 = "KK677"; //and 
	//let h2 = "KTJJT";
	//let gt = is_hand_gt2(h1, h2);
	//println(h1, " > ", h2, " = ", gt);

	let idx = bubble_sort_hands(hands);
	println("sorted hands = ");
	for i in [0: n]
	{
		println(hands[idx[i]]);
		//println("adding ", (i + 1), " * ", bids[idx[i]]);
		//println();

		sum_ += (i + 1) * bids[idx[i]];
	}

	println("part 2 = ", sum_);
	sum_;
}

//==============================================================================

fn main()
{
	println();
	println("Starting AOC syntran main");

	//part1();
	part2();

	println("Ending AOC syntran main");
	println();
}

//==============================================================================

main();

//==============================================================================

