
// This file includes a single hash map dictionary that maps str keys to i64
// values.  The primary functions for setting and getting key/value pairs are:
//
//     set_dict_i64(key: str, val: i64)
//     get_dict_i64(key: str): i64
//
// There are several related functions:
//
//     keys_dict_i64(): [str; :]  // return a flat array of all keys
//     vals_dict_i64(): [i64; :]  // return a flat array of all values
//     print_lens_dict_i64()      // print the length of each bucket in the dict

// TODO: copy this into the syntran repo and cover it with unit test(s)

//********

// The choice of the max hash fn return value offers a time/space tradeoff for
// hash clash resolutions.  Smaller max hashes yield a smaller array of buckets
// in the dict but increase the frequency of hash clashes and lookup times.
// Larger max hashes take more memory but lead to faster lookups due to fewer
// clashes
//
// 256 is optimial for aoc 2024 day 11

let HASH_MAX_DICT = 256;
//HASH_MAX_DICT = 32; // 2x as slow compared to 256 for aoc 2024 day 11
//HASH_MAX_DICT = 128;
//HASH_MAX_DICT = 512;
//HASH_MAX_DICT = 1024 * 64;

//==============================================================================

// TODO: move hash fns to a shared dict_common.syntran file?  If users include
// both dict_i32 and dict_i64 this will break

fn hash_aoc(s: str): i32
{
	// This is the hash fn from aoc 2023 day 15
	let hash_ = 0;
	for j in [0: len(s)]
	{
		hash_ += i32(s[j]);
		hash_ *= 17;
		hash_ %= HASH_MAX_DICT;
	}
	//println("hash_ = ", hash_);
	return hash_;
}

fn hash_djb2(s: str): i32
{
	// djb2 hash fn
	let hash_ = 5381;
	for j in [0: len(s)]
	{
		//hash_ = ((hash_ << 5) + hash_) + i32(s[j]);
		hash_ = hash_ * 33 + i32(s[j]);
	}
	hash_ %= HASH_MAX_DICT;
	if (hash_ < 0) hash_ += HASH_MAX_DICT;

	//println("djb2 = ", hash_);
	return hash_;
}

fn hash_str_dict(s: str): i32
{
	// This is the hash fn that determines which bucket a key goes into

	return hash_djb2(s);
	//return hash_aoc(s);
}

struct dict_i64_bucket
{
	cap: i32,
	len: i32,
	keys: [str; :],
	vals: [i64; :],
}

struct dict_i64
{
	len: i32,
	buckets: [dict_i64_bucket; :],
}

//fn init_dict_i64(): dict_i64
//{
	// TODO: arg?
	//let len_glbl = 256;
	let len_glbl64 = HASH_MAX_DICT;

	let empty_bucket_glbl64 = dict_i64_bucket
	{
		cap = 0,
		len = 0,
		keys = [""   ; 0],
		vals = [0'i64; 0],
	};

	let DICT_I64 = dict_i64
	{
		len = len_glbl64,
		buckets = [empty_bucket_glbl64; len_glbl64],
	};

	//return dict;
//}

fn print_lens_dict_i64()
{
	for i in [0: DICT_I64.len]
	{
		let len_ = DICT_I64.buckets[i].len;
		if len_ != 0
		{
			println("bucket[", i, "] len = ", len_);
			//println("bucket[", i, "] cap = ", DICT_I64.buckets[i].cap);
		}
	}
	return;
}

fn get_dict_i64(key: str): i64
{
	let ib = hash_str_dict(key); // bucket index
	let len_ = DICT_I64.buckets[ib].len;
	for i in [0: len_]
	{
		if DICT_I64.buckets[ib].keys[i] == key
		{
			return DICT_I64.buckets[ib].vals[i];
		}
	}
	// TODO: should we panic?
	return -1'i64;
	//return 0;
}

fn keys_dict_i64(): [str; :]
{
	// Return a flat array of all the keys in the dict
	let n = 0;
	for i in [0: DICT_I64.len]
		n += DICT_I64.buckets[i].len;
	let keys = [""; n];
	let k = 0;
	for i in [0: DICT_I64.len]
	for j in [0: DICT_I64.buckets[i].len]
	{
		keys[k] = DICT_I64.buckets[i].keys[j];
		k += 1;
	}
	return keys;
}

fn vals_dict_i64(): [i64; :]
{
	// Return a flat array of all the vals in the dict
	let n = 0;
	for i in [0: DICT_I64.len]
		n += DICT_I64.buckets[i].len;
	let vals = [0'i64; n];
	let k = 0;
	for i in [0: DICT_I64.len]
	for j in [0: DICT_I64.buckets[i].len]
	{
		vals[k] = DICT_I64.buckets[i].vals[j];
		k += 1;
	}
	return vals;
}

fn set_dict_i64(key: str, val: i64)
{
	// TODO: we really need dict arg as reference (not value) for efficiency
	//
	// Modifies a dict DICT_I64 as a global var for now

	let ib = hash_str_dict(key); // bucket index

	let len_ = DICT_I64.buckets[ib].len;
	//let in_dict = false;
	for i in [0: len_]
	{
		if DICT_I64.buckets[ib].keys[i] == key
		{
			// Reset existing value
			DICT_I64.buckets[ib].vals[i] = val;
			return;
			//in_dict = true;
			//break;
		}
	}

	let cap_ = DICT_I64.buckets[ib].cap;
	if len_ >= cap_
	{
		// Grow arrays
		if cap_ == 0
			cap_ = 1;
		else
			cap_ *= 2;

		DICT_I64.buckets[ib].cap = cap_;
		let keys = DICT_I64.buckets[ib].keys;
		let vals = DICT_I64.buckets[ib].vals;

		DICT_I64.buckets[ib].keys = [""; cap_];

		DICT_I64.buckets[ib].vals = [0'i64 ; cap_];

		//DICT_I64.buckets[ib].keys[0: len_] = keys; // struct array slices not implemented :(
		//DICT_I64.buckets[ib].vals[0: len_] = vals;
		for i in [0: len_]
		{
			DICT_I64.buckets[ib].keys[i] = keys[i];
			DICT_I64.buckets[ib].vals[i] = vals[i];
		}
	}
	//println("setting ", key, ", ", val);

	// Append new key value pair
	DICT_I64.buckets[ib].keys[len_] = key;
	DICT_I64.buckets[ib].vals[len_] = val;
	DICT_I64.buckets[ib].len += 1;

	return;
}

//==============================================================================

//fn main(): i32
//{
//	// Unit tests
//
//	println("starting dict.syntran");
//
//	//init_dict_i64();
//	println("len   = ", DICT_I64.len);
//	println("len 0 = ", DICT_I64.buckets[0].len);
//	println("cap 0 = ", DICT_I64.buckets[0].cap);
//	//DICT_I64.buckets[0].cap = 7;
//	//println("cap 0 = ", DICT_I64.buckets[0].cap);
//
//	println("hash 'HASH' = ", hash_str_dict("HASH")); // 52
//	println("hash 'rn=1' = ", hash_str_dict("rn=1")); // 30
//	println("hash 'rn'   = ", hash_str_dict("rn"));   // 0
//	println("hash 'cm'   = ", hash_str_dict("cm"));   // 0 (hash clash, good for testing)
//
//	set_dict_i64("rn", 1'i64);
//	set_dict_i64("qp", 3'i64);
//	set_dict_i64("cm", 2'i64);
//	set_dict_i64("pc", 4'i64);
//	set_dict_i64("ot", 9'i64);
//	set_dict_i64("ab", 5'i64);
//
//	println("get 'rn' = ", get_dict_i64("rn"));
//	println("get 'qp' = ", get_dict_i64("qp"));
//	println("get 'cm' = ", get_dict_i64("cm"));
//	println("get 'pc' = ", get_dict_i64("pc"));
//	println("get 'ot' = ", get_dict_i64("ot"));
//	println("get 'ab' = ", get_dict_i64("ab"));
//
//	print_lens_dict_i64();
//
//	println("keys = ", keys_dict_i64());
//	println("vals = ", vals_dict_i64());
//
//	println("ending dict.syntran");
//	return 0;
//}
//return main();

