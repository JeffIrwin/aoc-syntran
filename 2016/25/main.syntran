
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = -1'i64;

	let ninstrs = countln_(filename);

	let instrs = [""; ninstrs];
	let arg0s  = [""; ninstrs];
	let arg1s  = [""; ninstrs];

	// Part 2 takes 2 minutes to run.  I guess a dictionary was a bad choice
	// although it simplifies getting/setting.  An array would have worked, or
	// the usual if/else

	let reg_keys = "abcd";

	let f = open(filename, "r");
	let str_ = readln(f);
	let i = 0;
	while not eof(f)
	{
		//println("str_ = ", str_);

		let words = split_(str_, " ");
		instrs[i] = words[0];
		arg0s [i] = words[1];
		if size(words, 0) >= 3
			arg1s [i] = words[2];

		i += 1;
		str_ = readln(f);
	}
	close(f);
	//println("instrs = ", instrs);
	//println("arg1s = ", arg1s);

	// Iterate over initial reg values to find required output

	//regs[0] = 1;
	//regs[0] = 3;
	//regs[0] = 7;
	let reg0 = -1;
	while true
	{
	reg0 += 1;

	let regs = [0; 4];
	regs[0] = reg0;
	//println("regs[0] = ", regs[0]);

	let nout = 0;
	let iptr = 0;
	while iptr < ninstrs
	{
		//println("iptr = ", iptr);
		//println("arg0 = ", arg0s[iptr]);

		//println("regs = ", regs);

		let arg0 = 0'i64;
		let ireg = scan(reg_keys, arg0s[iptr]);
		if ireg >= 0
			arg0 = regs[ireg];
		else
			arg0 = parse_i64(arg0s[iptr]);
		//println("arg0 = ", arg0);

		let instr = instrs[iptr];
		if instr == "cpy"
		{
			ireg = scan(reg_keys, arg1s[iptr]);
			regs[ireg] = arg0;
		}
		else if instr == "inc"
		{
			if (ireg >= 0) regs[ireg] += 1;
		}
		else if instr == "dec"
		{
			if (ireg >= 0) regs[ireg] -= 1;
		}
		else if instr == "jnz"
		{
			if arg0 != 0
			{
				let arg1 = 0'i64;
				let ireg = scan(reg_keys, arg1s[iptr]);
				if ireg >= 0
					arg1 = regs[ireg];
				else
					arg1 = parse_i64(arg1s[iptr]);
				iptr += arg1;
				continue;
			}
		}
		else if instr == "out"
		{
			let out = arg0;
			//println("    out ", out);

			if (nout % 2 == 0)
			{
				if (out != 0) break;
			}
			else
			{
				if (out != 1) break;
			}
			nout += 1;

			if (nout >= 128)
			{
				sum_ = reg0;
				break;
			}
		}
		else if instr == "tgl"
		{
			//println("tgl");
			let itgl = iptr + arg0;
			if itgl < 0 or itgl >= ninstrs
			{
				iptr += 1;
				continue;
			}

			let tgl_instr = instrs[itgl];
			if     tgl_instr  == "inc"
				instrs[itgl]   = "dec";
			else if tgl_instr == "dec"
				instrs[itgl]   = "inc";
			else if tgl_instr == "cpy"
				instrs[itgl]   = "jnz";
			else if tgl_instr == "jnz"
				instrs[itgl]   = "cpy";
			else if tgl_instr == "tgl"
				instrs[itgl]   = "inc";
		}
		iptr += 1;
	}
	if (sum_ >= 0) break;
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2016/25");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

