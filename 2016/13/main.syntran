
#include("../../utils.syntran");
#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let NDIRS = 4;
let DIRS =
[
	 0, -1, // up
	-1,  0, // left
	 0,  1, // down
	 1,  0  // right
	 ;
	 2, NDIRS
];

fn part1(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let fav_num = parse_i32(readln(f));
	close(f);
	//println("fav_num = ", fav_num);

	// Do a BFS with a queue.  Queue stores x, y, and distance
	let QCAP = 1024;
	let q = [-1; 3, QCAP];
	let qs = 0;
	let qe = 0;

	// Start at 1,1, *not* 0,0
	let x = 1;
	let y = 1;

	// Push
	q[:,qe] = [x, y, 0];
	qe += 1;

	// In practice, the searched space has reasonable bounds, so an array could
	// be used here
	let visited = new_dict_i64();

	// Target end location
	let xe = 31;
	let ye = 39;

	while true
	{
		if qs >= qe
		{
			println("Error: queue is empty!");
			exit(-1);
		}

		// Pop
		let x0    = q[0,qs];
		let y0    = q[1,qs];
		let dist0 = q[2,qs];
		qs += 1;
		//println("x0, y0 = ", [x0, y0]);

		if (get_dict_i64(&visited, str(x0, ",", y0)) == 1) continue;
		set_dict_i64(&visited, str(x0, ",", y0), 1'i64);

		if x0 == xe and y0 == ye
		{
			sum_ = dist0;
			break;
		}

		// Check neighbors
		for id in [0: NDIRS]
		{
			let x = x0 + DIRS[0, id];
			let y = y0 + DIRS[1, id];

			// Negatives are invalid, but there is no upper bound to the space
			if (x < 0) continue;
			if (y < 0) continue;

			let num = x*x + 3*x + 2*x*y + y + y*y + fav_num;

			// Count 1 bits in num
			let nbits = 0;
			for i in [0: 32]
				if ((num >> i) & 1 == 1) nbits += 1;

			// If nbits is odd, the location is a wall
			if (nbits % 2 == 1) continue;

			// Push
			q[:,qe] = [x, y, dist0+1];
			qe += 1;
		}

	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let sum_ = 0'i64;

	let f = open(filename, "r");
	let fav_num = parse_i32(readln(f));
	close(f);
	//println("fav_num = ", fav_num);

	// Do a BFS with a queue.  Queue stores x, y, and distance
	let QCAP = 1024;
	let q = [-1; 3, QCAP];
	let qs = 0;
	let qe = 0;

	// Start at 1,1, *not* 0,0
	let x = 1;
	let y = 1;

	// Push
	q[:,qe] = [x, y, 0];
	qe += 1;

	// In practice, the searched space has reasonable bounds, so an array could
	// be used here
	let visited = new_dict_i64();

	while true
	{
		if qs >= qe
			break; // not an error in part 2

		// Pop
		let x0    = q[0,qs];
		let y0    = q[1,qs];
		let dist0 = q[2,qs];
		qs += 1;
		//println("x0, y0 = ", [x0, y0]);

		if (get_dict_i64(&visited, str(x0, ",", y0)) == 1) continue;
		set_dict_i64(&visited, str(x0, ",", y0), 1'i64);

		if (dist0 >= 50) continue;

		// Check neighbors
		for id in [0: NDIRS]
		{
			let x = x0 + DIRS[0, id];
			let y = y0 + DIRS[1, id];

			// Negatives are invalid, but there is no upper bound to the space
			if (x < 0) continue;
			if (y < 0) continue;

			let num = x*x + 3*x + 2*x*y + y + y*y + fav_num;

			// Count 1 bits in num
			let nbits = 0;
			for i in [0: 32]
				if ((num >> i) & 1 == 1) nbits += 1;

			// If nbits is odd, the location is a wall
			if (nbits % 2 == 1) continue;

			// Push
			q[:,qe] = [x, y, dist0+1];
			qe += 1;
		}

	}
	sum_ = len_dict_i64(&visited);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2016/13");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

