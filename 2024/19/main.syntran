
#include("../../utils-2024.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): i64
{
	let sum_ = 0'i64;

	let f = open(filename);
	let str_ = readln(f);

	let a = split_(str_, ", ");
	let na = size(a, 0);
	//println("na = ", na);
	//println("a  = ", a);

	str_ = readln(f); // skip blank line

	str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);
		let len_str_ = len(str_);

		// Stack contains the length of the substring of `str_` that we've
		// matched so far
		let STACK_CAP = 128;
		let stack = [-1; STACK_CAP];
		let sptr = 0;

		stack[sptr] = 0; sptr += 1; // push

		let visited = [false; len_str_, na];

		let matched = false;
		while true
		{
			if (sptr == 0) break;

			// Pop
			sptr -= 1;
			let i = stack[sptr];
			//println("i = ", i);

			if (i == len_str_)
			{
				matched = true;
				break;
			}

			for ia in [0: na]
			{
				if (visited[i, ia]) continue;
				visited[i, ia] = true;

				if starts_with_(str_[i: len_str_], a[ia])
				{
					//println("starts_with_ ", i, " ", a[ia]);
					stack[sptr] = i + len(a[ia]); sptr += 1; // push

					if sptr >= STACK_CAP
					{
						println("Error: stack overflow");
						exit(-1);
					}
				}
			}
		}
		//println("matched = ", matched);
		if (matched) sum_ += 1;

		str_ = readln(f);
	}
	close(f);

	println("part 1 = ", sum_);
	return sum_;
}

fn part2(): i64
{
	let sum_ = 0'i64;

	let f = open(filename);
	let str_ = readln(f);

	// Array of smaller strings that we use to build a larger string
	let ain = split_(str_, ", ");
	let nain = i32(size(ain, 0));
	//println("nain = ", nain);
	//println("a  = ", a);

	str_ = readln(f); // skip blank line

	str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);
		let len_str_ = len(str_);

		// Prune words from input dictionary `ain` that never appear in the
		// current sentence `str_` to avoid them entirely.  I came up with this
		// optimization while working on BFS, but the suffix matcher could
		// probably perform well without it
		let a = ain;
		let na = 0;
		for ia in [0: nain]
		{
			let amin = index_   (str_, ain[ia]);
			if (amin < 0) continue;
			a[na] = ain[ia];
			na += 1;
		}
		//println("na = ", na);
		//println("a = ", a[0: na]);

		let len_a = [0; na];
		for ia in [0: na]
			len_a[ia] = len(a[ia]);
		//println("len_a = ", len_a);
		//exit(0);

		// Build a table of a list of `a` entries that exist starting at each
		// location of str_
		let starters  = [-1; na, len_str_];
		let nstarters = [ 0;     len_str_];
		for i in [0: len_str_]
		{
			for ia in [0: na]
			{
				if (starts_with_(str_[i: len_str_], a[ia]))
				{
					starters[ nstarters[i] , i] = ia;
					nstarters[i] += 1;
				}
			}
		}
		//println("starters = ", starters);
		//println("starters = ");
		//for i in [0: len_str_]
		//	println(starters[0: nstarters[i], i]);
		//println("nstarters = ", nstarters);


		// I struggled for a long time trying to use a stack to BFS the string
		// from the start to the end.  It turns out that it's better to avoid
		// BFS and work from the end of the string to the start instead.  This
		// approach iteratively counts suffixes and uses those cached counts to
		// sum up match counts towards the start of the string
		//
		// I had to look at the reddit megathread before I figured this out.
		// Mainly I looked at this recursive solution:
		//
		//     https://github.com/hugseverycat/aoc2024/blob/master/day19.py
		//
		// It still took me a while to figure out how to port the recursion to
		// an iterative algorithm


		// This is the number of total possible matches of a suffix from i to
		// end of str. There will be just a few short suffixes that match the
		// end, and then exponentiallly more as we get towards the start of the
		// str
		let nmatches = [0'i64; len_str_];

		// Base case: first, add up complete suffixes which match to the end of
		// the str
		for i in [0: len_str_]
			for ia in starters[0: nstarters[i], i]
				if len_a[ia] == len_str_ - i
					nmatches[i] += 1;
		//println("nmatches  = ", nmatches);

		// Now iterate from the end of the string to the start
		for i in [len_str_ - 1: -1: -1]
		{
			for ia in starters[0: nstarters[i], i]
			{
				// Check bounds
				if i + len_a[ia] < len_str_
				{
					// For every 1 substring match found here, we add all of the
					// suffix matches that have been found in previous
					// iterations
					nmatches[i] += nmatches[i + len_a[ia]];
				}
			}
		}
		//println("nmatches  = ", nmatches);
		//println("len_str_ = ", len_str_);

		// nmatches[0] is the total number of ways to build the whole string.
		// the other entries nmatches[i] are ways to build shorter suffixes
		// str_[i: end]
		sum_ += nmatches[0];

		//println();
		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return sum_;
}

//==============================================================================

fn main(): i64
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2024/19");

	let sum_ = 0'i64;

	// Expect 367 + 724388733465031
	sum_ += part1();
	sum_ += part2();

	println("Ending AOC syntran main");
	println();
	return sum_;
}

//==============================================================================

return main();

//==============================================================================

