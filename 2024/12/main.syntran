
#include("../../utils-2024.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let NDIRS = 4;
let DIRS =
[
	-1,  0,
	 1,  0,
	 0, -1,
	 0,  1
	 ;
	 2, NDIRS
];

fn part1(): i64
{
	let sum_ = 0'i64;

	let ny = countln_(filename);

	let f = open(filename);
	let str_ = readln(f);
	let nx = i32(len(str_));

	let chars = [""; nx, ny];

	for y in [0: ny]
	{
		//println("str_ = ", str_);
		for x in [0: nx]
			chars[x, y] = str_[x];

		str_ = readln(f);
	}
	close(f);
	//println("chars = ", chars);

	let visited      = [false; nx, ny];
	let ever_visited = [false; nx, ny];

	let stack = [-1; 2, nx * ny];

	for y0 in [0: ny]
	for x0 in [0: nx]
	{
		if (ever_visited[x0, y0]) continue;

		visited = false;
		let sptr = 0; // stack pointer

		stack[:, sptr] = [x0, y0]; sptr += 1;  // push
		let area = 0;
		let peri = 0;
		let char_ = chars[x0, y0];

		while sptr > 0
		{
			// pop next search location [x, y]
			sptr -= 1;
			let x = stack[0, sptr];
			let y = stack[1, sptr];

			if (visited[x, y]) continue;
			visited[x, y] = true;
			area += 1;
			peri += 4;

			// push reachable neighbors [xn, yn]
			for id in [0: NDIRS]
			{
				let xn = x + DIRS[0, id];
				let yn = y + DIRS[1, id];

				if (not in_bounds([0, 0], [xn, yn], [nx, ny])) continue;

				if (chars[xn, yn] != char_) continue;
				peri -= 1;

				stack[:, sptr] = [xn, yn]; sptr += 1;
			}
		}
		sum_ += area * peri;

		ever_visited = ever_visited or visited;
	}
	println("part 1 = ", sum_);
	return sum_;
}

fn part2(): i64
{
	let sum_ = 0'i64;

	let ny = countln_(filename);

	let f = open(filename);
	let str_ = readln(f);
	let nx = i32(len(str_));

	let chars = [""; nx, ny];

	for y in [0: ny]
	{
		//println("str_ = ", str_);
		for x in [0: nx]
			chars[x, y] = str_[x];

		str_ = readln(f);
	}
	close(f);
	//println("chars = ", chars);

	let visited      = [false; nx, ny];     // cells visited
	let pvisited     = [false; nx+1, ny+1]; // points visited
	let ever_visited = [false; nx, ny];

	let stack = [-1; 2, nx * ny];

	for y0 in [0: ny] {
	//println("y0 = ", y0);
	for x0 in [0: nx]
	{
		if (ever_visited[x0, y0]) continue;

		visited  = false;
		pvisited = false;
		let sptr = 0; // stack pointer

		stack[:, sptr] = [x0, y0]; sptr += 1;  // push
		let area = 0;
		let char_ = chars[x0, y0];

		while sptr > 0
		{
			// pop next search location [x, y]
			sptr -= 1;
			let x = stack[0, sptr];
			let y = stack[1, sptr];

			if (visited[x, y]) continue;
			visited[x, y] = true;
			area += 1;

			// push reachable neighbors [xn, yn]
			for id in [0: NDIRS]
			{
				let xn = x + DIRS[0, id];
				let yn = y + DIRS[1, id];

				if (not in_bounds([0, 0], [xn, yn], [nx, ny])) continue;
				if (chars[xn, yn] != char_) continue;

				stack[:, sptr] = [xn, yn]; sptr += 1;
			}
		}

		if (not any(visited)) continue;

		// Count angles after the DFS loop above.  Number of angles is the same
		// as number of sides
		let nang = 0;

		// Iterate the entire grid of points.  You could optimize this by only
		// iterating over the bounding box (plus 1 appropriately) of the visited
		// region
		for py in [0: ny + 1] {
		//println("py = ", py);
		for px in [0: nx + 1]
		{
			// Point p == [px, py] is in the middle surrounded by 4 cells like this:
			//
			//    +-----+-----+
			//    |  c0 |  c1 |
			//    |     |     |
			//    +-----+-----+
			//    |     |p    |
			//    |  c2 |  c3 |
			//    +-----+-----+
			//
			// The number of angles at point p depends on which of c[0-4] are in
			// the current "visited" region.  There are 10 cases with 1 or 2 angles

			let cx = -1; let cy = -1;

			// Are cells in region?
			let c0 = false;
			let c1 = false;
			let c2 = false;
			let c3 = false;

			cx = px - 1; cy = py - 1;
			if (in_bounds([0,0], [cx,cy], [nx,ny])) c0 = visited[cx, cy];

			cx = px - 0; cy = py - 1;
			if (in_bounds([0,0], [cx,cy], [nx,ny])) c1 = visited[cx, cy];

			cx = px - 1; cy = py - 0;
			if (in_bounds([0,0], [cx,cy], [nx,ny])) c2 = visited[cx, cy];

			cx = px - 0; cy = py - 0;
			if (in_bounds([0,0], [cx,cy], [nx,ny])) c3 = visited[cx, cy];

			if (c0 and not any([c1, c2, c3])) nang += 1;
			if (c1 and not any([c2, c3, c0])) nang += 1;
			if (c2 and not any([c3, c0, c1])) nang += 1;
			if (c3 and not any([c0, c1, c2])) nang += 1;

			if (not c0 and all([c1, c2, c3])) nang += 1;
			if (not c1 and all([c2, c3, c0])) nang += 1;
			if (not c2 and all([c3, c0, c1])) nang += 1;
			if (not c3 and all([c0, c1, c2])) nang += 1;

			if (c0 and c3 and not c1 and not c2) nang += 2;
			if (c1 and c2 and not c0 and not c3) nang += 2;

			// The other 4 cases are 0 angles (4 straight edge cases and 2 cases
			// with everything outside or everything inside)
		}}

		sum_ += area * nang;

		ever_visited = ever_visited or visited;
	}}
	println("part 2 = ", sum_);
	return sum_;
}

//==============================================================================

fn main(): i64
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2024/12");

	let sum_ = 0'i64;

	sum_ += part1();
	sum_ += part2();

	println("Ending AOC syntran main");
	println();
	return sum_;
}

//==============================================================================

return main();

//==============================================================================

