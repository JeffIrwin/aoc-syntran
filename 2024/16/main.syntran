
#include("../../utils-2024.syntran");
#include("../../minheap_vec_i32.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

let NDIRS = 4;
let DIRS =
[
	-1,  0, // west
	 1,  0, // east
	 0, -1, // north
	 0,  1  // south
	 ;
	 2, NDIRS
];
let WEST  = 0;
let EAST  = 1;
let NORTH = 2;
let SOUTH = 3;

// Number of state variables.  State contains:
//
//     0. score, aka distance
//     1. x pos
//     2. y pos
//     3. direction (encoded as a single i32 from enum above)
//
let NSTATE = 4;

// Queue data structure.  I don't have pass-by-reference but I do have
// pass-by-global-variable :)
let QUEUE_CAP = 2 * 1024 * 1024;
let queue = [-1; NSTATE, QUEUE_CAP];
let queue_beg  = 0;
let queue_end  = 0;
let queue_end0 = 0;

fn sort_queue()
{
	// Quick sort

	//println("starting qsort()");
	////println("queue = ", queue);

	let l = queue_beg;
	let h = queue_end - 1;

	if (l < h)
	{
		let stack = [0; h - l + 1];

		let top = -1;

		top += 1;
		stack[top] = l;

		top += 1;
		stack[top] = h;

		while top >= 0
		{
			h = stack[top];
			top -= 1;

			l = stack[top];
			top -= 1;

			// TODO: use median-of-3 pivot like later day(s)
			let x = queue[0,h];

			let i = l - 1;
			for j in [l: h]
				if queue[0,j] <= x
				{
					i += 1;
					for k in [0: NSTATE]
					{
						// TODO: slice instead of loop
						let tmp     = queue[k, i];
						queue[k, i] = queue[k, j];
						queue[k, j] = tmp;
					}
				}
			for k in [0: NSTATE]
			{
				let tmp       = queue[k, i+1];
				queue[k, i+1] = queue[k, h];
				queue[k, h] = tmp;
			}

			let p = i + 1;

			if p - 1 > l
			{
				top += 1;
				stack[top] = l;
			
				top += 1;
				stack[top] = p - 1;
			}

			if p + 1 < h
			{
				top += 1;
				stack[top] = p + 1;

				top += 1;
				stack[top] = h;
			}
		}
	}
	//println("queue = ", queue);

	// This could also prune popped elements entirely to avoid QUEUE_CAP issues
	while queue[0, queue_beg] < 0 and queue_beg < queue_end
		queue_beg += 1;

	// After sorting, new unsorted elements will be pushed onto the queue after
	// this position
	queue_end0 = queue_end;
	return;
}

let push_count = 0;
fn push_(v: [i32; :])
{
	//println("pushing ", v);
	if queue_end >= QUEUE_CAP
	{
		println("Error: QUEUE_CAP overflow!");
		exit(-1);
	}
	queue[:, queue_end] = v;
	queue_end += 1;

	// Sort the queue periodically for perf.  This is a poor man's priority
	// queue / min heap
	if push_count % 3000 == 0
	//if push_count % 500 == 0
		sort_queue();

	push_count += 1;
	return;
}

fn pop_(): [i32; :]
{
	// Linear scan because I'm not implementing a min-heap queue :(

	// queue_beg is guaranteed to be in the queue (i think)
	let i = queue_beg;
	let imin = i;
	let min_ = queue[0,i];

	// Scan only the unsorted part of the queue
	let x = [-1; NSTATE];
	i = queue_end0;
	while i < queue_end
	{
		if queue[0,i] >= 0
		{
			if queue[0,i] < min_
			{
				min_ = queue[0,i];
				imin = i;
			}
		}
		i += 1;
	}
	x = queue[:, imin];

	queue[0, imin] = -1;  // mark popped element as out of queue

	// When queue[0,:] happens to get popped, increment it to the next element
	// still in queue
	while queue[0, queue_beg] < 0 and queue_beg < queue_end
		queue_beg += 1;

	return x;
}

fn part1(): i64
{
	let sum_ = 0'i64;

	let chars = read_char_mat(filename);
	let nx = i32(size(chars, 0));
	let ny = i32(size(chars, 1));
	//println("chars = ", chars);

	// Find start and end points
	let xs = -1;
	let ys = -1;
	let xe = -1;
	let ye = -1;
	for y in [0: ny]
	for x in [0: nx]
	{
		if chars[x,y] == "S"
		{
			xs = x;
			ys = y;
		}
		else if chars[x,y] == "E"
		{
			xe = x;
			ye = y;
		}
	}
	//println("xys = ", [xs, ys]);

	// Dijkstra's algorithm with a proper (binary tree) minheap priority queue
	let DIST_INFTY = 2_000_000_000;
	let dist = [DIST_INFTY; nx, ny, NDIRS];
	let visited = [false  ; nx, ny, NDIRS];

	// `prev` is only needed to backtrack the whole path. we don't need it to
	// get the optimal score/dist

	// Initialize source vertex to 0 distance
	dist[xs, ys, EAST] = 0;
	let q = new_minheap_vec_i32();
	push_minheap_vec_i32(&q, [0, xs, ys, EAST]);

	let dist_end = DIST_INFTY;
	let dist_progress = dist_end + 1;
	while q.len > 0 // TODO: make an is_empty_minheap*() fn
	{
		let u = pop_minheap_vec_i32(&q);

		// unpack from array
		let dist0 = u[0];
		let x0    = u[1];
		let y0    = u[2];
		let dir0  = u[3];

		if x0 == xe and y0 == ye
			dist_end = min(dist_end, dist0);

		if (dist_end < dist_progress)
		{
			dist_progress = dist_end;
			//println("dist_progress = ", dist_progress);
		}

		if (visited[x0, y0, dir0]) continue;
		visited[x0, y0, dir0] = true;

		for dir in [0: NDIRS]
		{
			let x = x0 + DIRS[0, dir];
			let y = y0 + DIRS[1, dir];

			// Check bounds and walls
			if (not in_bounds([0,0], [x,y], [nx,ny])) continue;
			if (chars[x,y] == "#") continue;

			let alt = dist0 + 1;
			if (dir != dir0) alt += 1000;

			if alt < dist[x, y, dir]
			{
				dist[x, y, dir] = alt;
				push_minheap_vec_i32(&q, [alt, x, y, dir]);
			}
		}
	}
	sum_ = dist_end;

	println("part 1 = ", sum_);
	return sum_;
}

fn part2(): i64
{
	let sum_ = 0'i64;

	let chars = read_char_mat(filename);
	let nx = i32(size(chars, 0));
	let ny = i32(size(chars, 1));
	//println("chars = ", chars);

	// Find start and end points
	let xs = -1;
	let ys = -1;
	let xe = -1;
	let ye = -1;
	for y in [0: ny]
	for x in [0: nx]
	{
		if chars[x,y] == "S"
		{
			xs = x;
			ys = y;
		}
		else if chars[x,y] == "E"
		{
			xe = x;
			ye = y;
		}
	}
	//println("xys = ", [xs, ys]);

	// Dijkstra's algorithm with bad O(n) pop_() linear scan
	let DIST_INFTY = 2_000_000_000;
	let dist = [DIST_INFTY; nx, ny, NDIRS];
	let visited = [false  ; nx, ny, NDIRS];

	// Prev has a `4` dimension here because we need to keep track of *all*
	// equally optimal paths that lead from the start to the end.  nprev is
	// incremented to track this
	let nprev = [ 0       ; nx, ny, NDIRS];
	let prev  = [-1       ; 4, NSTATE, nx, ny, NDIRS];

	// Initialize source vertex to 0 distance
	dist[xs, ys, EAST] = 0;
	push_([0, xs, ys, EAST]);

//  1  function Dijkstra(Graph, source):
//  2     
//  3      for each vertex v in Graph.Vertices:
//  4          dist[v] ← INFINITY
//  5          prev[v] ← UNDEFINED
//  6          add v to Q
//  7      dist[source] ← 0
//  8     

	let dist_end = DIST_INFTY;
	let dist_progress = dist_end + 1;
	let dir_end = -1;
	while queue_beg < queue_end
	{
		let u = pop_();

		// unpack from array
		let dist0 = u[0];
		let x0    = u[1];
		let y0    = u[2];
		let dir0  = u[3];

		if x0 == xe and y0 == ye
		{
			if dist0 <= dist_end
			{
				//println("dist0 = ", dist0);
				dist_end = dist0;
				dir_end  = dir0;
			}
		}

		if (dist_end < dist_progress)
		{
			dist_progress = dist_end;
			//println("dist_progress = ", dist_progress);
		}

		if (visited[x0, y0, dir0]) continue;
		visited[x0, y0, dir0] = true;

		for dir in [0: NDIRS]
		{
			let x = x0 + DIRS[0, dir];
			let y = y0 + DIRS[1, dir];

			// Check bounds and walls
			if (not in_bounds([0,0], [x,y], [nx,ny])) continue;
			if (chars[x,y] == "#") continue;

			let alt = dist0 + 1;
			if (dir != dir0) alt += 1000;

			// Use `<=`, not `<`, to get all optimal paths, not just one
			if alt <= dist[x, y, dir]
			{
				dist[x, y, dir] = alt;

				let n = nprev[x, y, dir];
				nprev[x, y, dir] += 1;
				prev[n, :, x, y, dir] = u;

				push_([alt, x, y, dir]);
			}
		}
	}
//  9      while Q is not empty:
// 10          u ← vertex in Q with minimum dist[u]
// 11          remove u from Q
// 12         
// 13          for each neighbor v of u still in Q:
// 14              alt ← dist[u] + Graph.Edges(u, v)
// 15              if alt < dist[v]:
// 16                  dist[v] ← alt
// 17                  prev[v] ← u
// 18
// 19      return dist[], prev[]

	//println("dir_end = ", dir_end);
	//println("backtracking");

	// Backtrack all optimal paths
	let STACK_CAP = nx * ny * 10; // probably don't need 10x
	let stack = [-1; 3, STACK_CAP];
	let sptr = 0;

	// You can end facing north or east, because the end point is in the
	// top-right.  However, one of those might not be part of an optimal path
	if (dist[xe, ye, NORTH] == dist_end) { stack[:, sptr] = [xe, ye, NORTH]; sptr += 1; }
	if (dist[xe, ye, EAST ] == dist_end) { stack[:, sptr] = [xe, ye, EAST ]; sptr += 1; }

	visited = false;
	while sptr > 0
	{
		// Pop
		sptr -= 1;
		let x0   = stack[0, sptr];
		let y0   = stack[1, sptr];
		let dir0 = stack[2, sptr];

		//println("xy0 dir0 = ", [x0, y0, dir0]);

		chars[x0, y0] = "O";

		if (visited[x0, y0, dir0]) continue;
		visited[x0, y0, dir0] = true;

		for i in [0: nprev[x0, y0, dir0]]
		{
			let x   = prev[i, 1, x0, y0, dir0];
			let y   = prev[i, 2, x0, y0, dir0];
			let dir = prev[i, 3, x0, y0, dir0];
			stack[:, sptr] = [x, y, dir]; sptr += 1;
		}
	}
	chars[xs, ys] = "O";
	//println("chars = ", chars);
	print_char_mat(&chars);

	sum_ = count(chars == "O");

	println("part 2 = ", sum_);
	return sum_;
}

//==============================================================================

fn main(): i64
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2024/16");

	let sum_ = 0'i64;

	// Expect 73432 + 496

	sum_ += part1();
	//sum_ += part2(); // TODO

	println("Ending AOC syntran main");
	println();
	return sum_;
}

//==============================================================================

return main();

//==============================================================================

