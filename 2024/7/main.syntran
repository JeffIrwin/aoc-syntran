
#include("../../utils-2024.syntran");
#include("../../dict_i64.syntran");
HASH_MAX_DICT_I64 = 2048;
HASH_MAX_DICT_I64 = 8192;

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn base3(a: i32): [i32; :]
{
	// Convert `a` to base 3.  Max 12 (base 3) digits allowed.  This is ok for
	// the value of nvmax
	//
	// Now generalize in utils
	let res = [0'i32; 12];
	for i in [0: 12]
	{
		let r = a % 3;
		a /= 3;
		res[i] = r;  // endianness is not important for aoc problem
		if (a == 0) break;
	}
	//println("base3 = ", res);
	return res;
}

fn part1(): i64
{
	let sum_ = 0'i64;

	let f = open(filename);
	let str_ = readln(f);
	let nvmax = 0'i64;
	while not eof(f)
	{
		//println("str_ = ", str_);

		let strs = split_(str_, ":");

		let ans = parse_i64(strs[0]);
		let v = parse_i64_delim(strs[1], " ");
		//println("ans = ", ans);
		//println("v = ", v);

		let nv = size(v, 0);
		nvmax = max(nvmax, nv);
		for i in [0: 2 ** (nv - 1)] // permutations
		{
			let res = v[0];
			for j in [1: nv]
			{
				//println("j = ", j);
				let vb = v[j];
				let op_bit = 1'i64 & (i >> (j-1));
				if (op_bit == 0)
					res += vb;
				else
					res *= vb;
				//println("res = ", res);
			}
			if res == ans
			{
				//println("expected ans = ", ans);
				sum_ += ans;
				break;
			}
		}
		//println();
		str_ = readln(f);
	}
	close(f);
	println("nvmax = ", nvmax);

	println("part 1 = ", sum_);
	return sum_;
}

fn part2(): i64
{
	let sum_ = 0'i64;

	let k = 0; // debug progress only
	let f = open(filename);
	let str_ = readln(f);
	while not eof(f)
	{
		println("k = ", k);
		k += 1;
		//println("str_ = ", str_);

		let strs = split_(str_, ":");

		let ans = parse_i64(strs[0]);
		let v = parse_i64_delim(strs[1], " ");

		let nv = i32(size(v, 0));
		//println("nv = ", nv);

		// Are you fucking kidding me?  Just saving every permutation in a big
		// ass array is faster than any of the clever stuff that I tried?
		let nums  = [0'i64; 3 ** (nv-1)];
		let nums0 = nums;
		nums[0] = v[0]; let ptr = 1;
		for i in [1: nv]
		{
			nums0 = nums;
			let ptr0 = ptr;
			ptr = 0;
			for j in [0: ptr0]
			{
				nums[ptr] = nums0[j] + v[i]; ptr += 1;
				nums[ptr] = nums0[j] * v[i]; ptr += 1;
				nums[ptr] = parse_i64(str(nums0[j], v[i])); ptr += 1;
			}
		}
		if any(nums == ans)
			sum_ += ans;
		str_ = readln(f);
		continue;
		// TODO: dead code below

		//// This is based on a reddit post.  I'm using a dict as a set:
		////
		////     https://www.reddit.com/r/adventofcode/comments/1h8l3z5/comment/m39dj4i/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
		////
		//// Unfortunately it's slow AF and I don't think there are many
		//// duplicates that provide savings as a set
		//let nums  = new_dict_i64();
		//let nums0 = new_dict_i64();
		//set_dict_i64(&nums, str(v[0]), v[0]);
		//for i in [1: nv]
		//{
		//	//println("v[i] = ", v[i]);
		//	nums0 = nums;
		//	nums  = new_dict_i64();
		//	for num0 in vals_dict_i64(&nums0)
		//	{
		//		//println("num0 = ", num0);
		//		let x = -1'i64;
		//		x = num0 + v[i]               ; set_dict_i64(&nums, str(x), x);
		//		x = num0 * v[i]               ; set_dict_i64(&nums, str(x), x);
		//		x = parse_i64(str(num0, v[i])); set_dict_i64(&nums, str(x), x);
		//	}
		//}
		//if get_dict_i64(&nums, str(ans)) >= 0
		//	sum_ += ans;
		//str_ = readln(f);
		//continue;
		//// TODO: dead code below

		let nop = nv - 1;  // one less operator than value
		let op = [0; nop];
		let idig = -1;  // digit index

		// Cache results in this array until each op digit rolls over.  On most
		// iterations (exactly 2/3), only the last operator is different.  I
		// think you could more aggresively cache from the right of the current
		// op digit too using a dict somehow, but the left-to-right order of
		// operations and non-commutative concat op makes it complicated
		let results = [v[0]; nv];

		while true
		{
			//println("op = ", op);
			//println("results = ", results);

			let j0 = 1;
			if (idig >= 0) j0 = nop - idig;
			let res = results[j0 - 1];

			for j in [j0: nv]
			{
				let vb = v[j];

				let op_bit = op[nop - j];
				if (op_bit == 0)
					res += vb;
				else if (op_bit == 1)
					res *= vb;
				else
				{
					// concat (in base ten)
					res = parse_i64(str(res) + str(vb));
				}
				results[j] = res;
			}

			if res == ans
			{
				//println("expected ans = ", ans);
				sum_ += ans;
				break;
			}

			// Increment op vec as if it's a base-3 big num with digit 0 as the
			// least significant digit.  You could reverse the digits but it
			// seemed natural to do it this way, with a lot af `x - idig` above
			idig = 0;
			while op[idig] == 2
			{
				idig += 1;
				if (idig >= nop) break;
			}
			if (idig >= nop) break;
			op[0: idig] = 0;
			op[idig] += 1;
		}
		//println();
		str_ = readln(f);
	}
	close(f);

	println("part 2 = ", sum_);
	return sum_;
}

//==============================================================================

fn main(): i64
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2024/7");

	let sum_ = 0'i64;

	// Expect 4364915411363 + 38322057216320
	sum_ += part1();
	sum_ += part2();

	println("Ending AOC syntran main");
	println();
	return sum_;
}

//==============================================================================

return main();

//==============================================================================

