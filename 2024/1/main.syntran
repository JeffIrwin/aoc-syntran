
// Test input
let INPUT_STR = "3   4
4   3
2   5
1   3
3   9
3   3";

// Real input
INPUT_STR = "76569   66648
38663   66530
60350   60777
35330   13469
88681   66648
30057   83262
55455   13469
48398   40350
60451   61801
23979   80612
20498   47207
18170   73737
27928   35371
45219   20896
13289   77147
24458   32690
33053   45373
30998   96652
63320   53803
18321   62925
47393   64433
71112   96929
21392   87748
60110   75803
45686   82976
43026   50513
23080   25876
81346   96652
45701   27282
67858   52482
61483   98326
52308   60692
98286   78044
99386   28829
31064   24022
90518   76616
86055   77147
77548   78368
67600   59182
13410   10920
14441   94982
73737   70248
61602   67267
88419   40092
31757   26048
51810   97947
37775   64433
42112   31426
82029   97947
84902   75016
77147   72913
55928   74888
30168   26337
35206   62925
76009   87748
51573   21184
54931   74888
23466   65978
34344   62436
56118   89076
57495   27190
20063   84666
50850   60277
94982   65172
82710   50401
54893   97947
17029   13015
31042   27282
77274   21521
36836   66530
64993   32013
36429   67456
14228   60117
93810   77235
82201   55336
11071   59405
62119   76671
74858   78380
16332   64287
41635   61870
26392   19133
30081   79653
46852   54621
61987   40810
45439   13469
16638   72913
46884   64433
78775   41746
28266   21471
50240   21359
36216   18921
63061   80604
55186   48458
33521   67895
88738   32324
17872   27128
42966   67895
74894   66648
68870   72913
32631   89974
22114   32324
54345   94982
79241   40092
75791   30915
89775   64433
36196   62925
97340   64433
70717   66530
97532   74017
17841   85558
64433   96652
57281   77235
60158   68395
38601   31426
95768   67206
74339   96114
72283   66153
66648   88997
77312   64433
24237   65172
34725   80360
81905   45373
49368   66530
70080   74811
36941   56793
25380   65172
75150   40092
95428   65463
65063   75803
95286   97947
76555   67896
69305   72913
46692   19873
60637   79234
70348   40092
63575   87748
18822   86165
10053   45373
32355   92574
33467   59368
78154   27282
21154   67895
34321   62925
63763   31426
41970   57327
95379   32324
29009   75157
57863   27282
93891   71556
55942   26584
51505   97947
57349   56723
18516   26076
47757   26741
88631   64859
82224   66648
94668   97947
37537   63594
84583   67896
62925   31426
83652   21593
48631   78044
34328   70839
17959   12466
92497   79654
74945   52837
30957   96669
20808   74035
68043   78044
92100   27282
83140   67895
50451   54565
99877   28626
17414   84687
74459   73737
71551   10197
48028   64325
45144   20896
77667   38950
55278   33966
50857   78698
71058   62925
14884   32559
26322   35307
19517   72482
61263   67885
41865   20896
46019   74888
84622   58250
72924   74609
65922   82910
57609   97333
96221   54856
58965   96652
48467   66648
38822   30889
89271   78044
50233   64433
72132   45373
50114   87748
92854   22607
68597   49674
31426   77235
26290   64433
46519   64433
99530   77235
24195   31586
24855   21184
12474   79094
79857   21593
84581   20896
14589   92512
27460   21340
95913   80901
96860   32324
68478   48576
61539   53107
54264   19299
11712   67896
67895   47673
21806   32758
94924   62925
79279   78044
71937   39743
38121   78795
99405   66123
23777   32324
15904   78795
57158   64433
90077   94982
27713   55706
94225   35262
26741   86365
76579   53276
98566   87748
96383   31426
34920   35972
30857   44851
72631   28903
97426   75803
90023   10480
42078   72456
29177   61870
15290   92102
30020   31426
48828   92102
55399   50795
92532   96652
84224   48473
56107   21184
94015   15651
74539   66648
46023   67896
65289   27607
76828   61870
31980   70248
29563   77235
37156   16468
90827   91595
90960   19133
52081   22332
37539   41719
45714   54298
33020   61870
65172   66530
48114   78775
95266   75803
14319   86650
15016   35732
44772   80035
13318   55618
66222   52117
52139   87748
89430   11409
94339   75803
51914   62825
49546   19721
77235   33966
34977   58765
32268   94658
32335   78795
87797   78044
70688   27282
34550   65172
48762   71542
36225   33519
14156   37230
54748   33966
60824   62925
23664   80089
75308   17866
85167   27282
31875   87748
80274   97947
53914   19133
65328   87748
15842   70248
64679   34977
72913   72913
26977   50674
18805   79402
50403   92493
66822   66530
25130   78795
43179   73939
28529   90781
84485   98917
88144   64096
19444   80359
25094   77147
23999   94224
76777   66648
80395   87748
87765   75803
54941   97947
35440   50102
47296   40092
82072   33966
99634   66367
66069   67895
38850   75803
30653   77235
56745   45373
21852   74888
19323   94982
83540   88668
83398   40092
68475   35769
32324   94982
75842   24467
75024   92102
30361   31426
23965   16174
89063   66946
33958   47913
52713   92695
79512   27282
57978   89624
67269   66530
52343   94982
68862   38090
23827   48146
78795   70248
51665   94193
22205   33442
44361   82174
32727   61173
51222   83595
69372   48212
87748   96669
20468   75346
64252   31030
85477   67895
74888   35830
15886   92371
50741   63054
91573   90762
64501   40092
58070   47184
48736   52006
86830   66648
42764   20896
39435   75803
57300   23024
27997   29297
94682   45384
63535   63310
61579   69125
76805   50707
80476   27282
78044   33966
20073   65172
60476   78795
67653   25683
59888   30469
51791   62925
69612   27282
92872   98790
76912   92147
39675   87781
18997   78044
39931   80845
54580   34977
80984   66702
28979   66122
90883   87748
87336   32324
15586   20896
54359   91784
61884   67895
47021   97947
44988   45373
81841   61262
10463   31426
20507   45373
42642   31426
45174   45373
98791   92102
26063   86304
53202   61016
68734   77235
11240   61870
89762   40475
26879   43813
35769   33966
86763   80861
23079   63219
62599   77147
90177   68212
89027   13469
78085   31979
23181   23639
60101   43169
70182   43769
76082   65349
23126   44490
94557   85732
39903   92382
53351   92674
27851   12772
55945   19133
94512   31426
59442   40411
46111   72913
33188   40092
69496   45373
53706   49971
84226   51998
84530   21593
15619   92382
92909   32324
82233   92102
32228   83737
22622   75803
87096   80553
45821   64433
53028   41007
87359   39533
24280   87748
33180   45751
29942   78775
62815   36056
34378   33966
19267   59240
41823   22936
19487   66588
35166   33993
53863   96652
37077   22763
21593   78795
15250   83295
97412   75803
41281   92126
50748   61126
85109   73737
93496   78795
89991   33966
21350   78044
83836   67895
99183   87748
83195   64433
57577   13469
86197   58388
75241   48318
28959   32286
19106   33966
24181   13469
58346   27282
64260   40092
63855   37643
51041   46410
12780   85519
39423   85172
15750   31426
96117   72913
48705   66648
60266   40092
56098   54353
84332   62925
59843   21593
47823   79304
92701   37931
44807   75803
87047   77312
12269   20353
32926   46463
87543   27282
37843   19133
89968   61047
81630   20896
78677   21184
97744   32324
42608   51250
80685   81741
50122   14161
13469   64433
46215   62925
19736   66530
33883   37191
57314   73055
97638   19870
53667   92382
57195   61870
25721   33774
26068   40724
25422   72913
21805   45373
30357   19952
84783   64433
51674   32324
31130   64009
66530   87748
56565   82436
45075   66648
20799   40855
62469   18007
29429   25209
28582   78775
63901   15901
82320   62925
13257   70997
60804   77312
90339   40092
42668   65172
24336   67895
26868   89300
50073   98326
84600   30003
65452   77235
95481   73588
70538   48925
99276   77147
92621   19133
91369   97947
52612   24257
36522   17658
70248   97947
88603   23450
14573   70248
67260   89145
51191   98661
44550   49884
14867   96392
40341   77267
36004   77312
81443   78902
76574   53093
87171   17683
75979   61667
74276   32324
35093   13469
83347   62925
61220   27315
75436   90108
91705   67308
44016   21184
77374   85349
56171   21593
12623   77147
67912   22652
62519   97947
50408   34621
92685   77147
69052   76862
90063   92382
19924   11561
24684   40421
94603   65926
93869   66530
36287   48082
19610   67895
41304   70125
80834   99853
73110   79715
34006   80678
49159   50399
94986   90400
23162   65172
87756   45373
78614   92102
48810   91710
30686   75803
93411   85238
92796   62925
33708   83052
69230   88895
80346   97913
31632   31088
49454   96652
87503   32324
12993   67895
24790   16973
27278   77235
31393   97947
13890   32206
45822   65172
76509   66648
73570   27282
68202   65172
11950   62321
86295   40092
59431   21184
10073   34977
46959   43185
38024   77147
59467   65244
97947   64378
52066   33745
78026   72913
67778   20896
36416   90870
28572   20178
43037   96652
13183   78390
95497   31577
59588   31486
87551   74948
47751   60762
64227   33966
25037   96652
69189   79055
78690   72913
97053   33515
86924   74892
21239   12234
70294   94982
64633   66530
63033   77235
20972   67896
57094   28665
66334   78044
84175   45373
69423   85516
59629   92102
26492   56269
24233   88192
42703   38887
43484   27282
25830   97275
27148   32324
70173   63820
37962   21712
53875   73269
62770   30421
84383   56860
38809   78044
14689   37568
58731   40092
69616   68542
12184   61542
19032   37467
21184   40092
81673   65172
92102   35259
50429   18155
41374   87748
62668   40678
38465   21184
48412   74888
85695   66183
85327   76099
40141   48103
78149   34977
19512   75803
90774   24724
30680   70248
33876   13469
48744   87748
41261   34680
94345   66648
17561   77462
82921   13469
22353   51441
66005   67895
31257   45373
47358   70248
89407   31426
16602   27282
77071   32324
33095   94179
92791   27577
90001   45373
76457   64433
45373   82791
26903   27282
94655   61226
87065   64433
59434   26586
31424   78044
98326   31294
67336   65172
63174   57462
91623   91717
30997   57264
16487   56799
36955   67895
41035   95689
40808   78044
70906   12597
83126   68388
27778   34977
29362   96669
96931   34603
49573   77235
17169   65172
62241   81818
44935   84669
56537   31733
70264   10099
53581   20896
10468   21683
72084   96652
10700   29942
95034   54507
95618   85158
44077   18069
62523   75803
73000   65172
86080   27282
70455   55085
86887   39416
36257   66530
69290   13469
84621   45373
28070   27127
67896   71818
91077   60253
28096   58231
82719   62925
13753   62925
13359   73882
73187   56847
46578   37833
51474   29377
59914   13469
32994   29637
47213   64433
27705   20268
43458   42766
55713   70932
88478   67896
76437   71309
47552   30154
61870   14538
82030   60684
66782   57234
58762   77235
73779   66648
39491   97947
56237   48563
39046   67465
83723   75437
15550   96669
45705   72913
61209   75803
34422   62925
48150   32431
54683   10076
80717   78795
73513   62925
17391   40092
93794   64433
61475   59675
53260   77235
28755   89046
61345   99015
70447   19133
17075   95443
38645   77312
34399   79947
96669   80873
53242   81188
73388   38294
43262   45373
57113   35769
99180   23536
71205   26741
23208   66648
16013   66648
48327   33966
54890   23799
35094   42350
91186   37676
57274   87515
75941   61870
57396   75803
26112   67895
54308   77312
16053   65172
92418   45373
33397   22627
68006   13273
71144   27282
41560   28813
11541   61870
12314   20591
84666   35769
45896   20896
37274   67618
25332   12025
47691   67895
19593   88018
59745   52030
16391   21184
48465   77312
27282   20896
44459   79545
56759   21184
31978   77312
49713   60159
71736   77235
48701   94495
58335   77312
85731   77235
36730   87187
24576   61551
16255   77312
86861   77232
44160   20365
42957   77235
37675   21184
46289   19117
32863   67895
44893   63700
19026   77147
14203   62925
79022   20896
90878   64104
28194   50591
99094   17191
83283   67895
97463   94724
21838   99767
33966   34741
31560   37806
51238   77312
87950   66471
97414   62666
22335   73671
43355   21593
33567   40218
77568   61870
73302   43649
20178   94062
41008   40771
61032   77312
92382   40092
28557   74888
66152   50621
55335   40092
94368   34977
96652   64433
39401   21593
33854   54721
12726   70248
58078   40066
86375   88605
93905   66648
73642   74437
10862   96669
69937   21184
16483   80995
33726   32324
91167   68312
49496   97947
40092   79306
88996   78795
87107   33435
95555   59150
10341   94764
85542   77312
67878   23706
23412   92102
50765   20896
32794   62925
96832   97699
83174   77235
64070   21184
54569   40092
96530   96652
17512   94982
71376   42379
75803   16374
85967   31426
34569   70248
96867   97811
56321   22248
31972   98519
11367   79119
16755   77147
33148   23891
27699   92382
58246   34977
81416   96566
64682   74553
14103   31426
97226   40092
76494   69441
33262   43363
83176   63786
44601   39137
19627   35769
82257   74888
33338   40646
65644   20178
40304   40092
63980   25399
35134   33966
78787   54216
31147   98280
70378   45373
96224   50505
75530   34977
43443   31426
17552   28034
15131   86681
59594   73729
74481   61870
91569   19681
67128   78795
63154   77235
51586   98318
41213   20368
66534   98097
49095   98255
25436   21184
95020   43385
93614   82529
46555   62461
35898   17460
63537   31992
71258   91047
92852   67895
97125   20896
88632   75803
57247   96652
20277   67895
10269   85485
46681   78417
31928   44190
12487   21184
76196   77312
24895   10004
46101   87748
26438   21593
86041   67868
99574   74888
14990   20896
42622   24596
76205   62925
88565   45373
88447   65172
11332   28176
47458   21931
19133   36318
58142   35444
77904   53938
45223   20384
32352   96652
88508   81769
35832   47885
79827   77014
53932   33966
16064   92102
73085   20896
17739   99652
54478   67896
28744   57632
87515   93313
86271   93951
15579   74888
51749   62314
46430   30608
24869   67896
97219   88722
13106   21184
22072   66530
67674   65974
68925   55818
33588   21184
95625   65172
31443   87748
94542   32961
21244   20482
38829   68138
68255   77147
39081   16035
25336   16043
31219   92382
87477   53823
29146   45373
37019   65172
94223   65172
20896   34977
15884   86356
76809   13023
56403   10503
23533   40965
82416   74888
24373   20896";

// START UTILS BLOCK

//==============================================================================

let digit_chars = "0123456789";
let hex_chars = digit_chars + "abcdef";

//==============================================================================

fn countln_(filename: str): i32
{
	let nlines = 0;

	let f = open(filename);
	let str_ = readln(f);
	while not eof(f)
	{
		//println("str_ = ", str_);
		nlines += 1;

		str_ = readln(f);
	}
	close(f);

	return nlines;
}

//==============================================================================

fn scan(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic scan()

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = i64(0);
	while not found and i < len(str_)
	{

		let j = 0;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	if (found)
		i -= 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn scanback(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic scan() with back = true

	//println("str_ = ", str_);
	//println("set = ", set);

	let found = false;
	let i = len(str_) - 1;
	while not found and i >= 0
	{

		let j = i64(0);
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i -= 1;
	}
	//println("found = ", found);

	if (found)
		i += 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn verify(str_: str, set: str): i64
{
	// c.f. Fortran intrinsic verify()

	//println("starting verify()");
	//println("str_ = """, str_, """");
	//println("set = ", set);

	let found = true;
	let i = i64(0);
	while found and i < len(str_)
	{
		//println(i);

		let j = 0;
		found = false;
		while not found and j < len(set)
		{
			//found = str_[i] != set[j];
			//found = not (str_[i] == set[j]);
			found = str_[i] == set[j];
			j += 1;
		}
		i += 1;
	}

	if (not found)
		i -= 1;
	else
		i = i64(-1);
	return i;
}

//==========================================================

fn tok_i32(str_: str): [i64; :]
{
	// tokenize a string into the first int contained within it, then return the
	// substring start index, end index, and length

	//println("starting tok_i32()");
	//println("str_ = """, str_, """");

	let nums = "1234567890";
	let beg_ = scan    (str_, nums);
	//println("beg_ = ", beg_);

	let n = len(str_);
	//println("n = ", n);

	// nasty bug which was just fixed
	let len_ = i64(-1);
	if (beg_ >= 0)
		len_ = verify(str_[beg_:n], nums);
	//println("len_ = ", len_);

	let end_ = i64(-1);
	if (beg_ < 0)
	{
		//println("no beg_");
	}
	else if (len_ < 0)
	{
		// This is consistent with the way that verify() works in Fortran
		end_ = n - 1;
		len_ = end_ - beg_ + 1;
	}
	else
		end_ = beg_ + len_ - 1;

	//println("beg_ = ", beg_);
	//println("end_ = ", end_);

	//println("num beg = ", str_[beg_]);
	//println("num end = ", str_[end_]);
	//println("num str = ", str_[beg_: end_+1]);

	return [beg_, end_, len_];
}

//==========================================================

fn read_i32(str_: str): i32
{
	let toks = tok_i32(str_);

	// multiple return vals are packed into a vec bc i don't have structs :sad:
	let beg_ = toks[0];
	let end_ = toks[1];
	//let len_ = toks[2]; // not needed

	//println("read_i32 substr = ", str_[beg_: end_+1]);

	let ans = parse_i32(str_[beg_: end_+1]);
	//println("read_i32 = ", ans);

	return ans;
}

fn read_i32s(str_: str): [i32; :]
{
	// Parse a vector of i32 integers from a string.  Any non-int characters are
	// treated as delimiters

	let i = i64(0);
	let n = len(str_);

	//println("str_ = ", str_);
	//println("n = ", n);

	//let toks = i64([0, 0, 0]);
	let toks = [i64(0); 3];
	let num_nums = 0;  // the number of numbers

	while toks[0] >= 0
	{
		//println("i = ", i);
		toks = tok_i32(str_[i:n]);
		//println("toks = ", toks);
		//println("num = ", num);
		num_nums += 1;
		i += toks[1] + 1;
	}
	num_nums -= 1;

	let nums = [0; num_nums];
	i = i64(0);
	for j in [0: num_nums]
	{
		//println("i = ", i);
		toks = tok_i32(str_[i:n]);
		//println("toks = ", toks);
		let num = parse_i32(str_[i + toks[0]: i + toks[1]+1]);
		//println("num = ", num);
		nums[j] = num;
		//num_nums += 1;
		i += toks[1] + 1;
	}

	return nums;
}


//==============================================================================

fn verifyback(str_: str, set: str): i64
{
	//println("");
	//println("starting verifyback");
	//println("str_ = ", str_);
	//println("set  = ", set);

	let i = len(str_) - 1;
	let found = true;
	while found and i >= 0
	{
		let j = 0;
		found = false;
		while not found and j < len(set)
		{
			found = str_[i] == set[j];
			j += 1;
		}
		i -= 1;
	}

	let ans = i64(-1);
	if not found
	{
		//println("ans = ", i + 1);
		ans = i + 1;
	}
	return ans;
}

//==============================================================================

//==============================================================================

fn is_digit(char_: str): bool
{
	// TODO: optimize with i32() char casting, like is_alpha()
	return scan(char_, digit_chars) >= 0;
}

fn is_alpha(char_: str): bool
{
	return
		(i32("a") <= i32(char_) and i32(char_) <= i32("z")) or
		(i32("A") <= i32(char_) and i32(char_) <= i32("Z"));
}

//==============================================================================

// TODO: rename to any_char_eq_str or any_char_eq_set
fn any_str_eq_set(str_: str, set: str): bool
{
	return scan(str_, set) >= 0;
}

//==============================================================================

fn any_mat(v: [bool; :, :]): bool
{
	let found = false;
	let i = 0;
	while i < size(v, 1) and not found
	{
		let j = 0;
		while j < size(v, 0) and not found
		{
			found = v[j,i];
			j += 1;
		}
		i += 1;
	}
	return found;
}

//==============================================================================

fn any_r3(v: [bool; :, :, :]): bool
{
	let found = false;
	let i = 0;
	while i < size(v, 2) and not found
	{
		let j = 0;
		while j < size(v, 1) and not found
		{
			let k = 0;
			while k < size(v, 0) and not found
			{
				found = v[k,j,i];
				k += 1;
			}
			j += 1;
		}
		i += 1;
	}
	return found;
}

//==============================================================================

fn minloc_mat(dist: [i32; :, :], q: [bool; :, :]): [i32; :]
{
	let found = false;
	let min_ = -1;
	let minloc_ = [-1, -1];
	for y in [0: size(dist,1)]
	for x in [0: size(dist,0)]
	{
		if q[x,y]
		{
			if found
			{
				//min_ = min(min_, dist[x,y]);
				if (dist[x,y] < min_)
				{
					min_ = dist[x,y];
					minloc_ = [x, y];
				}
			}
			else
			{
				found = true;
				min_ = dist[x,y];
				minloc_ = [x, y];
			}
		}
	}
	//let ans = min_;
	return minloc_;
}

//==============================================================================

fn minloc_r3(dist: [i32; :, :, :], q: [bool; :, :, :]): [i32; :]
{
	let found = false;
	let min_ = -1;
	let minloc_ = [-1, -1];
	for z in [0: size(dist,2)]
	for y in [0: size(dist,1)]
	for x in [0: size(dist,0)]
	{
		if q[x,y,z]
		{
			if found
			{
				if (dist[x,y,z] < min_)
				{
					min_ = dist[x,y,z];
					minloc_ = [x, y, z];
				}
			}
			else
			{
				found = true;
				min_ = dist[x,y,z];
				minloc_ = [x, y, z];
			}
		}
	}
	//let ans = min_;
	return minloc_;
}

//==============================================================================

// TODO: rename to any_str_eq_vec
fn any_str_eq(str_: str, v: [str; :]): bool
{
	//if (any_str_eq(my_num, wn_nums_str)) nwin = 1;

	let found = false;
	let i = 0;
	while i < size(v, 0) and not found
	{
		found = str_ == v[i];
		i += 1;
	}
	return found;
}

//==============================================================================

fn index_(str_: str, substr: str): i64
{
	//println("str_   = ", str_);
	//println("substr = ", substr);

	let nsub = len(substr);

	let i = i64(0);
	let found = false;
	while not found and i < len(str_) - len(substr) + 1
	{

		found = str_[i: i+nsub] == substr;

		////println("i = ", i);
		//let j = 0;
		//found = true;
		//while found and j < len(substr)
		//{
		//	//println("j = ", j);
		//	found = str_[i+j] == substr[j];
		//	j += 1;
		//}

		i += 1;
		//i = i + 1;
	}

	if found
	{
		i -= 1;
		//println("str_ = ", str_);
		//println("str_[] = ", str_[i: i + len(substr)]);
		//println("substr = ", substr);
		//println();
		return i;
	}
	else
	{
		//println("not found");
		return i64(-1);
	}
}

//==============================================================================

fn indexback(str_: str, substr: str): i64
{
	//println("str_   = ", str_);
	//println("substr = ", substr);

	let nsub = len(substr);

	let i = len(str_) - len(substr);
	let found = false;
	while not found and i >= 0
	{

		found = str_[i: i+nsub] == substr;

		////println("i = ", i);
		//let j = 0;
		//found = true;
		//while found and j < len(substr)
		//{
		//	//println("j = ", j);
		//	found = str_[i+j] == substr[j];
		//	j += 1;
		//}
		i -= 1;
	}

	if found
	{
		i += 1;
		//println("str_ = ", str_);
		//println("str_[] = ", str_[i: i + len(substr)]);
		//println("substr = ", substr);
		//println();
		return i;
	}
	else
	{
		//println("not found");
		return i64(-1);
	}
}

//==============================================================================

fn split_(str_: str, delims: str): [str; :]
{
	// Split an input str_ into a vector of strs based on a set of delimiters

	//println("starting split_()");
	//println("str_ = """, str_, """");

	let n = len(str_);
	//println("n = ", n);

	let nout = 0;
	if (any_str_eq_set(str_[0], delims)) nout -= 1;

	// First pass: count delimited strings
	let i = 0;
	while i < n
	{
		//println("i = ", i);
		let i0 = i;

		i = scan  (str_[i:n], delims) + i0;
		if (i < i0) i = n;

		i0 = i;
		i = verify(str_[i:n], delims) + i0;
		if (i < i0) i = n;
		//i += 1;

		nout += 1;
	}
	//println("nout = ", nout);

	let out = [""; nout];

	nout = 0;
	if (any_str_eq_set(str_[0], delims)) nout -= 1;

	// Second pass: save split strings
	i = 0;
	while i < n
	{
		//println("i = ", i);
		let i0 = i;

		i = scan  (str_[i:n], delims) + i0;
		if (i < i0) i = n;

		if (nout >= 0) out[nout] = str_[i0: i];

		i0 = i;
		i = verify(str_[i:n], delims) + i0;
		if (i < i0) i = n;
		//i += 1;

		nout += 1;
	}
	return out;
}

//==============================================================================

fn parse_i32_hex(str_: str): i32
{
	// Read a hexadecimal number *without* any leading `0x` or `#` or anything
	// besides literal hex characters

	let num = 0;
	for ii in [0: len(str_)]
	{
		let i = len(str_) - ii - 1;
		let c = str_[i];
		let val = scan(hex_chars, c);
		num += i32(val * 16 ** ii);
	}
	return num;
}

//==============================================================================

fn parse_i32_delim(str_: str, delims: str): [i32; :]
{
	let str_vec = split_(str_, delims);
	//println("str_vec = ", str_vec);
	let vec = [i32(0); size(str_vec, 0)];
	for i in [0: size(str_vec, 0)]
		vec[i] = parse_i32(str_vec[i]);
	return vec;
}

//==============================================================================

fn parse_i64_delim(str_: str, delims: str): [i64; :]
{
	let str_vec = split_(str_, delims);
	//println("str_vec = ", str_vec);
	let vec = [i64(0); size(str_vec, 0)];
	for i in [0: size(str_vec, 0)]
		vec[i] = parse_i64(str_vec[i]);
	return vec;
}

//==============================================================================

fn rm_char(str_: str, char_: str): str
{
	// Remove all occurences of a char from a str

	// allocate to max possible length
	let out = str_;

	let j = 0;
	for i in [0: len(str_)]
	{
		if not (str_[i] == char_)
		{
			out[j] = str_[i];
			j += 1;
		}
	}

	// trim
	return out[0: j];
}

fn reverse_str(str_: str): str
{
	// Reverse a str
	let rev = str_;
	let n = len(str_);
	for i in [0: n]
		rev[i] = str_[n-i-1];
	return rev;
}

//==============================================================================

fn ends_with_(str_: str, char_: str): bool
{
	return str_[ len(str_) - 1 ] == char_;
}

fn all_ends_with_(strs: [str; :], j: [i32; :], char_: str): bool
{
	let i = 0;
	let all_end = true;
	while all_end and i < size(j, 0)
	{
		all_end = ends_with_(strs[j[i]], char_);
		i += 1;
	}
	return all_end;
}

//==============================================================================

fn gcd64(a: i64, b: i64): i64
{
	// Euclidean algorithm for GCD
	while b != 0
	{
		let t = b;
		b = a % b;
		a = t;
	}
	return a;
}

fn lcm64(a: i64, b: i64): i64
{
	let abs_ = a * b;
	if (abs_ < 0) abs_ = -abs_;
	return abs_ / gcd64(a, b);
}

fn abs_i32(a: i32): i32
{
	let abs_ = a;
	if (abs_ < 0) abs_ = -abs_;
	return abs_;
}

//==============================================================================

fn sign_(x: i32): i32
{
	let s = 0;
	if x > 0
		s = +1;
	else if x < 0
		s = -1;
	return s;
}

fn sign_64(x: i64): i64
{
	let s = i64(0);
	if x > 0
		s = +i64(1);
	else if x < 0
		s = -i64(1);
	return s;
}

//==============================================================================

fn sum_i32(v: [i32; :]): i32
{
	let sum_ = 0;
	for i in [0: size(v,0)]
		sum_ += v[i];
	return sum_;
}

//==============================================================================

fn pmod(i: i32, n: i32): i32
{
	// Modulo/remainder but always positive
	//
	// TODO: this is actually wrong
	return (i % n + n) % n;
}

//==============================================================================
// END UTILS BLOCK

// from aoc 2023/25
// TODO: add to utils
fn qsort(v: [i32; :]): [i32; :]
{
	// Quick sort algorithm.  Return index array instead of modifying the input
	// array in-place

	//println("starting qsort()");
	//println("v = ", v);

	let l = 0;
	let h = i32(size(v,0)) - 1;

	let ix = [l: h + 1];

	if l < h
	{
		let stack = [0; h - l + 1];

		let top = -1;

		top += 1;
		stack[top] = l;

		top += 1;
		stack[top] = h;

		while top >= 0
		{
			//println("h = ", h);
			h = stack[top];
			top -= 1;

			l = stack[top];
			top -= 1;

			// Median-of-three pivot.  40x faster for AOC day 21!
			let m = (l + h) / 2;
			if v[ix[m]] < v[ix[l]]
			{
				let tmp = ix[m];
				ix[m]   = ix[l];
				ix[l]   = tmp;
			}
			if v[ix[h]] < v[ix[l]]
			{
				let tmp = ix[h];
				ix[h]   = ix[l];
				ix[l]   = tmp;
			}
			if v[ix[m]] < v[ix[h]]
			{
				let tmp = ix[m];
				ix[m]   = ix[h];
				ix[h]   = tmp;
			}
			let x = v[ix[h]];

			let i = (l - 1);
			for j in [l: h]
				if v[ix[j]] <= x
				{
					i += 1;
					let tmp = ix[i];
					ix[i]   = ix[j];
					ix[j]   = tmp;
				}
			let tmp = ix[i+1];
			ix[i+1] = ix[h];
			ix[h]   = tmp;
			let p = i + 1;

			if p - 1 > l
			{
				top += 1;
				stack[top] = l;

				top += 1;
				stack[top] = p - 1;
			}

			if p + 1 < h
			{
				top += 1;
				stack[top] = p + 1;

				top += 1;
				stack[top] = h;
			}
		}
	}
	//println("v = ", v);
	//let ans = v;
	return ix;
}

//==============================================================================
                        
fn part1(): i32
{
    println("starting part 1");
    let sum_ = 0;

    let NEWLINE = char(10);
    
    let lines = split_(INPUT_STR, NEWLINE);
    let nlines = size(lines, 0);
    // println("nlines = ", nlines);

    let v1 = [0; nlines];
    let v2 = [0; nlines];
    for i in [0: nlines]
    {
        let line = lines[i];
        // println("line = ", line);

        let nums = parse_i32_delim(line, " ");
        v1[i] = nums[0];
        v2[i] = nums[1];
    }
    // println("v1 = ", v1);
    // println("v2 = ", v2);

    let i1 = qsort(v1);
    let i2 = qsort(v2);
    // println("i1 = ", i1);
    // println("i2 = ", i2);

    //// You could just get ans in one-line in fortran:
    // sum_ = abs(v1[i1] - v2[i2]);

    for i in [0: nlines]
    {
        sum_ += abs_i32(v1[i1[i]] - v2[i2[i]]);
    }

    println("part 1 = ", sum_);
    return sum_;
}
              
fn part2(): i32
{
    println("starting part 2");
    let sum_ = 0;

    let NEWLINE = char(10);
    
    let lines = split_(INPUT_STR, NEWLINE);
    let nlines = size(lines, 0);
    // println("nlines = ", nlines);

    let v1 = [0; nlines];
    let v2 = [0; nlines];
    for i in [0: nlines]
    {
        let line = lines[i];
        // println("line = ", line);

        let nums = parse_i32_delim(line, " ");
        v1[i] = nums[0];
        v2[i] = nums[1];
    }
    // println("v1 = ", v1);
    // println("v2 = ", v2);

    // Use a brute force O(n**2) nested for loop.  n is 1000, so it's 1_000_000 which isn't bad
    for j1 in [0: nlines]
    {
        let appearances = 0;
        for j2 in [0: nlines]
        {
            if v1[j1] == v2[j2]
                appearances += 1;
        }
        // println("appearances = ", appearances);
        sum_ += v1[j1] * appearances;
    }

    //// If you wanted to optimize this implementation, you could sort again
    //// like in part 1, and then do a bisection search on the 2nd list to count
    //// the number of appearances.  Better yet, traverse both lists at the same
    //// time, in sorted order and in sync to skip the need for bisection

    // let i1 = qsort(v1);
    // let i2 = qsort(v2);

    println("part 2 = ", sum_);
    return sum_;
}

fn main(): i32
{
    println("starting aoc main");

    // Expect part 1 = 3246517 and part 2 = 29379307
    let p1 = part1();
    let p2 = part2();
    
    println("ending aoc main");
    return 0;
}

return main();

