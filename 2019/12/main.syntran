
#include("../../utils.syntran");
#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let np = countln_(filename);
	let p = [0; 3, np];
	let f = open(filename, "r");
	for i in [0: np]
	{
		let str_ = readln(f);
		//println("str_ = ", str_);
		p[:,i] = read_mi32s(str_);
	}
	close(f);
	//println("p = ", p);

	let v = [0; 3, np];

	let ntime = 1000;
	for it in [0: ntime]
	{
		for i0 in [0: np]
		for i1 in [0: np]
		for id in [0: 3]
		{
			// Apply "gravity"
			v[id, i0] += sign_( p[id, i1] - p[id, i0] );
		}
		//println("v = ", v);

		// Update positions
		p += v;

		// "Energy"
		let energy = 0;
		for i in [0: np]
			energy += sum(abs(p[:,i])) * sum(abs(v[:,i]));
		//sum_ = sum(abs(p)) + sum(abs(v));
		sum_ = energy;

		//println("p = ", p);
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn is_strictly_sorted(v: [i32; :]): bool
{
	for i in [0: size(v, 0) - 1]
		if v[i] >= v[i+1]
			return false;
	return true;
}

fn part2(): str
{
	let sum_ = 0'i64;

	let np = countln_(filename);
	let p = [0; 3, np];
	let f = open(filename, "r");
	for i in [0: np]
	{
		let str_ = readln(f);
		//println("str_ = ", str_);
		p[:,i] = read_mi32s(str_);
	}
	close(f);
	//println("p = ", p);

	// Backup initial state
	let p0 = p;

	// TODO: do we need offset of cycle too?  Guess not
	let cycles = [0'i64; 3];

	// Each dimension cycles independently.  We can simulate them one-by-one,
	// and then get the overall cycle as the LCM of each dimension's cycle
	for id_nonzero in [0: 3]
	{
		//p = 0;
		let px = p0[id_nonzero, :];

		let idx = [0; np];

		//let pp = px;  // px "previous". i would use p0 but that's already used :(

		let v = [0; np];
		let a = [0; np];
		let seen = new_dict_i64();
		let it = 0;
		while true
		{
			//println("it = ", it);
			let key = str(px) + ":" + str(v);
			let last_seen = get_dict_i64(&seen, key);
			if last_seen >= 0
			{
				println("Seen state before at step ", last_seen);
				cycles[id_nonzero] = it;
				break;
			}
			set_dict_i64(&seen, key, i64(it));

			// Running with recalculation caching took 8m48.755s
			//
			// Running with brute-force recalculation on every step took 8m33.754s


			//let recalculate = false;

			////let idx0 = idx;
			//if not is_strictly_sorted(px[idx])
			//{
			//	idx = sort_index(px);
			//	recalculate = true;
			//}
			////println("idx = ", idx);

			//if not recalculate
			//{
			//	if any(px[idx[0: np-1]] == px[idx[1: np]])
			//		recalculate = true;
			//	else if any(pp[idx[0: np-1]] == pp[idx[1: np]])
			//		recalculate = true;
			//}

			//if recalculate
			//{
				// Accelerations don't change in most* time increments unless
				// planets cross
				//
				// You only really need to add/sub 1 or 2 to the previous
				// accelerations of the two planets that cross (or there could
				// be multiple pairs of planets that cross in one step).  With
				// only 4 planets, I'm not sure how to track that bookkeeping
				// data more efficiently than just sorting
				//
				// *it's actually frequent enough that this doesn't save any
				// time

				a = 0;
				for i0 in [1: np]
				for i1 in [0: i0]
				{
					// Apply "gravity"
					let s = sign_( px[i1] - px[i0] );
					a[i0] += s;
					a[i1] -= s;
				}
			//}
			//println("v = ", v);

			// Update velocities
			v += a;

			// Update positions
			//pp = px;
			px += v;

			it += 1;
		}
	}
	println("cycles = ", cycles);
	println("lcm64 = ", lcm64(lcm64(cycles[0], cycles[1]), cycles[2]));

	sum_ = lcm64(lcm64(cycles[0], cycles[1]), cycles[2]);

	println("part 2 = ", sum_);
	return str(sum_);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2019/12");

	let p1 = ""; let p2 = "";

	//p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

