
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
//ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let pairs = read_i32_mat_delim(filename, "/");
	println("pairs = ", pairs);

	let npairs = size(pairs, 1);
	println("npairs = ", npairs);

	let match_num = 0;
	let used = [false; npairs];

	sum_ = dfs(&pairs, &used, match_num);

	println("part 1 = ", sum_);
	return str(sum_);
}

fn dfs(pairs: &[i32; :, :], used: &[bool; :], match_num: i32): i32
{
	let npairs = size(pairs, 1);
	for i in [0: npairs]
	{
		if (used[i]) continue;

		if pairs[0,i] == match_num
		{
			used[i] = true;
			return sum(pairs[:,i]) + dfs(&pairs, &used, pairs[1,i]);
		}
		else if pairs[1,i] == match_num
		{
			used[i] = true;
			return sum(pairs[:,i]) + dfs(&pairs, &used, pairs[0,i]);
		}
	}
	return 0;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/24");

	let p1 = ""; let p2 = "";

	p1 = part1();
	//p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

