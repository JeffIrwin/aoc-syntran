
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let s = "abcdefghijklmnop";
	let ns = len(s);

	let f = open(filename, "r");
	let str_ = readln(f);
	//println("str_ = ", str_);
	close(f);

	for word in split_(str_, ",")
	{
		//println("word = ", word);
		let nw = len(word);
		if word[0] == "s"
		{
			let n = parse_i32(word[1:nw]);
			//println("spin = ", n);

			s = s[ns - n: ns] + s[0: ns - n];
		}
		else if word[0] == "x"
		{
			let xs = split_(word[1:nw], "/");
			let x0 = parse_i32(xs[0]);
			let x1 = parse_i32(xs[1]);
			//println("x0, x1 = ", [x0, x1]);

			//s[[x0, x1]] = s[[x1, x0]];
			let t = s[x0];
			s[x0] = s[x1];
			s[x1] = t;
		}
		else if word[0] == "p"
		{
			let ps = split_(word[1:nw], "/");
			let p0 = ps[0];
			let p1 = ps[1];
			//println("p0, p1 = ", [p0, p1]);

			let x0 = scan(s, p0);
			let x1 = scan(s, p1);

			let t = s[x0];
			s[x0] = s[x1];
			s[x1] = t;
		}
		//println("s = ", s);
		//println();
	}

	println("part 1 = ", s);
	return s;
}

fn part2(): str
{
	let s = "abcdefghijklmnop";
	let s0 = s;
	let ns = len(s);

	let f = open(filename, "r");
	let str_ = readln(f);
	//println("str_ = ", str_);
	close(f);

	let words = split_(str_, ",");

	//println("s = ", s);
	//println();

	// I was hoping that each round of the "dance" would shuffle characters
	// according to the same permutation.  Unfortunately, the "partner"
	// operation (swapping by letter) breaks the predictable permutation across
	// rounds
	//
	// Fortunately, there is a small period cycle.  For me, I get back to
	// "abcdefghijklmnop" after 42 rounds.  Your cycle period will differ
	//
	// Search for this period length (up to CAP rounds max), and then we can
	// easily get the state after 1_000_000_000 rounds with a simple mod
	// operation

	let CAP = 1024;
	let ss = [""; CAP];

	let period = 0;
	for k in [0: CAP]
	{
		ss[k] = s;
		if (s == s0 and k > 0)
		{
			period = k;
			break;
		}

		//if (k % 1 == 0) println("k = ", k);
		for word in words
		{
			//println("word = ", word);
			let nw = len(word);
			if word[0] == "s"
			{
				let n = parse_i32(word[1:nw]);
				//println("spin = ", n);

				s = s[ns - n: ns] + s[0: ns - n];
			}
			else if word[0] == "x"
			{
				let xs = split_(word[1:nw], "/");
				let x0 = parse_i32(xs[0]);
				let x1 = parse_i32(xs[1]);
				//println("x0, x1 = ", [x0, x1]);

				//s[[x0, x1]] = s[[x1, x0]];
				let t = s[x0];
				s[x0] = s[x1];
				s[x1] = t;
			}
			else if word[0] == "p"
			{
				let ps = split_(word[1:nw], "/");
				let p0 = ps[0];
				let p1 = ps[1];
				//println("p0, p1 = ", [p0, p1]);

				let x0 = scan(s, p0);
				let x1 = scan(s, p1);

				let t = s[x0];
				s[x0] = s[x1];
				s[x1] = t;
			}
		}
		//println("s = ", s);
		//println();
	}
	//println("period = ", period);
	if period == 0
	{
		println("Error: could not find cycle");
		exit(-1);
	}
	s = ss[1_000_000_000 % period];

	println("part 2 = ", s);
	return s;
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/16");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

