
#include("../../utils.syntran");
//#include("../../dict_i64.syntran");

//==============================================================================

let ifile = 0;
ifile = 1;

let filenames =
[
	"test-input.txt",
	"input.txt"
];
let filename = filenames[ifile];

//==============================================================================

fn part1(): str
{
	let sum_ = 0'i64;

	let mat = read_i32_mat_delim(filename, ":");
	//println("mat = ", mat);

	let depths = mat[0,:];
	let ranges_sparse = mat[1,:];
	//println("depths = ", depths);
	//println("ranges_sparse = ", ranges_sparse);

	let max_depth = maxval(depths);
	let scanners = [-1; max_depth + 1];
	let ranges   = [-1; max_depth + 1];
	let dirs     = [ 1; max_depth + 1];
	//println("scanners = ", scanners);

	// Start at 0
	scanners[depths] = 0;
	//println("scanners = ", scanners);

	ranges[depths] = ranges_sparse;
	//println("ranges = ", ranges);

	for d in [0: max_depth + 1]
	{
		//println("d = ", d);
		if scanners[d] == 0
		{
			//println("caught");
			sum_ += d * ranges[d];
		}

		//println("scanners = ", scanners);
		for d in depths  // shadow
		{
			scanners[d] += dirs[d];
			if (scanners[d] == 0 or scanners[d] == ranges[d]-1) dirs[d] *= -1;
		}

		//println();
	}

	println("part 1 = ", sum_);
	return str(sum_);
}

fn part2(): str
{
	let mat = read_i32_mat_delim(filename, ":");
	//println("mat = ", mat);

	let depths = mat[0,:];
	let ranges_sparse = mat[1,:];
	let periods_sparse = 2 * ranges_sparse - 2;
	//println("depths = ", depths);
	//println("ranges_sparse = ", ranges_sparse);

	let max_depth = maxval(depths);

	//let scanners = [-1; max_depth + 1];
	let ranges   = [-1; max_depth + 1];
	ranges[depths] = ranges_sparse;

	let periods = ranges * 2 - 2;
	//println("ranges  = ", ranges );
	//println("periods = ", periods);
	//let dirs     = [ 1; max_depth + 1];
	//println("scanners = ", scanners);

	let t0 = 0;
	while true
	{
		//if (t0 % 10_000 == 0) println("t0 = ", t0);
		let sum_ = 0'i64;

		for i in [0: size(depths, 0)]
		{
			if (depths[i] + t0) % periods_sparse[i] == 0
			{
				sum_ = 1;
				break;
			}
		}

		//for d in [0: max_depth + 1]
		//{
		//	if periods[d] > 0 and (d + t0) % periods[d] == 0
		//	{
		//		sum_ = 1;
		//		break;
		//	}
		//}

		if (sum_ == 0) break;
		t0 += 1;
	}

	println("part 2 = ", t0);
	return str(t0);
}

//==============================================================================

fn main(): str
{
	// For unit-testing (within the syntran repo), this main fn returns a value
	// to be compared with expected results
	println();
	println("Starting AOC syntran main 2017/13");

	let p1 = ""; let p2 = "";

	p1 = part1();
	p2 = part2();

	println("Ending AOC syntran main");
	println();
	return p1 + ":" + p2;
}

//==============================================================================

return main();

//==============================================================================

